/*
 * Copyright (c) 1998 Robert Nordier
 * Copyright (c) 2025 Stefan EÃŸer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#ifdef MAKEFS
/* In the makefs case we only want struct disklabel */
#include <sys/disk/bsd.h>
#else
#include <sys/fdcio.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/mount.h>
#endif
#include <sys/endian.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/time.h>

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#ifdef WITH_ICONV
#include <iconv.h>
#include <locale.h>
#endif
#include <inttypes.h>
#include <paths.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "mkfs_msdos.h"

#define	MAXU16	  0xffff	/* maximum unsigned 16-bit quantity */
#define	BPN	  4		/* bits per nibble */
#define	NPB	  2		/* nibbles per byte */

#define	DOSMAGIC  0xaa55	/* DOS magic number */
#define	MINBPS	  512		/* minimum bytes per sector */
#define	MAXBPS	  4096		/* maximum bytes per sector */
#define	MAXSPC	  128		/* maximum sectors per cluster */
#define	MAXBPC_EX (1<<25)	/* maximum sectors per cluster exFAT */
#define	MAXNFT	  16		/* maximum number of FATs */
#define	MAXNFT_EX 2		/* maximum number of FATs exFAT */
#define	DEFBLK	  4096		/* default block size */
#define	DEFBLK16  2048		/* default block size FAT16 */
#define	DEFBLK_EX (128*1024)	/* default block size exFAT */
#define	DEFRDE	  512		/* default root directory entries */
#define	RESFTE	  2		/* reserved FAT entries */
#define	MINCLS12  1U		/* minimum FAT12 clusters */
#define	MINCLS16  0xff5U	/* minimum FAT16 clusters */
#define	MINCLS32  0xfff5U	/* minimum FAT32 clusters */
#define	MAXCLS12  0xff4U	/* maximum FAT12 clusters */
#define	MAXCLS16  0xfff4U	/* maximum FAT16 clusters */
#define	MAXCLS32  0xffffff4U	/* maximum FAT32 clusters */

#define	mincls(fat)  ((fat) == 12 ? MINCLS12 :	\
		      (fat) == 16 ? MINCLS16 :	\
				    MINCLS32)
#define	maxcls(fat)  ((fat) == 12 ? MAXCLS12 :	\
		      (fat) == 16 ? MAXCLS16 :	\
				    MAXCLS32)

#define	BOOTSEC		0	/* boot sector offset */
#define	EXTBOOTSEC	1	/* extended boot sector offset */
#define	EXTBOOTSECCNT	8	/* number of extended boot sectors */
#define	OEMPARMSEC	9	/* OEM parameter sector offset */
#define	RESERVEDSEC	10	/* reserved sector */
#define	BOOTCKSUMSEC	11	/* checksum sector */
#define	BACKUPSECOFS	12	/* backup boot sector region offset */

#define	EX_DE_ALLOCMAP		0x81	/* cluster allocation bitmap */
#define	EX_DE_UPCASETABLE	0x82	/* UTF-16 upper case translation */
#define	EX_DE_LABEL		0x83	/* volume label */

#define	mk1(p, x)	(p) = (u_int8_t)(x)
#define	mk2(p, x)	le16enc(p, x)
#define	mk4(p, x)	le32enc(p, x)

struct bs {
    u_int8_t bsJump[3];			/* bootstrap entry point */
    u_int8_t bsOemName[8];		/* OEM name and version */
} __packed;

struct bsbpb {
    u_int8_t bpbBytesPerSec[2];		/* bytes per sector */
    u_int8_t bpbSecPerClust;		/* sectors per cluster */
    u_int8_t bpbResSectors[2];		/* reserved sectors */
    u_int8_t bpbFATs;			/* number of FATs */
    u_int8_t bpbRootDirEnts[2];		/* root directory entries */
    u_int8_t bpbSectors[2];		/* total sectors */
    u_int8_t bpbMedia;			/* media descriptor */
    u_int8_t bpbFATsecs[2];		/* sectors per FAT */
    u_int8_t bpbSecPerTrack[2];		/* sectors per track */
    u_int8_t bpbHeads[2];		/* drive heads */
    u_int8_t bpbHiddenSecs[4];		/* hidden sectors */
    u_int8_t bpbHugeSectors[4];		/* big total sectors */
} __packed;

struct bsxbpb {
    u_int8_t bpbBigFATsecs[4];		/* big sectors per FAT */
    u_int8_t bpbExtFlags[2];		/* FAT control flags */
    u_int8_t bpbFSVers[2];		/* file system version */
    u_int8_t bpbRootClust[4];		/* root directory start cluster */
    u_int8_t bpbFSInfo[2];		/* file system info sector */
    u_int8_t bpbBackup[2];		/* backup boot sector */
    u_int8_t bpbReserved[12];		/* reserved */
} __packed;

struct bsx {
    u_int8_t exDriveNumber;		/* drive number */
    u_int8_t exReserved1;		/* reserved */
    u_int8_t exBootSignature;		/* extended boot signature */
    u_int8_t exVolumeID[4];		/* volume ID number */
    u_int8_t exVolumeLabel[11];		/* volume label */
    u_int8_t exFileSysType[8];		/* file system type */
} __packed;

struct bsexfat {
    u_int8_t bsJump[3];			/* bootstrap entry point */
    u_int8_t bsFileSystemName[8];	/* OEM name and version "EXFAT   " */
    u_int8_t bsUnused[53];		/* unused DOS parameter area */
    u_int8_t bsPartitionOffset[8];	/* start of partition on device */
    u_int8_t bsVolumeLength[8];		/* number of sectors in volume */
    u_int8_t bsFatOffset[4];		/* phys. sector of start of FAT */
    u_int8_t bsFatLength[4];		/* number of sectors per FAT */
    u_int8_t bsClusterHeapOffset[4];	/* phys. sector of cluster #2 */
    u_int8_t bsClusterCount[4];		/* number of clusters */
    u_int8_t bsRootClust[4];		/* start cluster for root directory */
    u_int8_t bsVolSerialNumber[4];	/* volume serial number */
    u_int8_t bsFSVers[2];		/* ExFat file system revision */
    u_int8_t bsVolumeFlags[2];		/* volume status, e.g. dirty */
    u_int8_t bsBytesPerSecShift;	/* log2 of bytes per sector */
    u_int8_t bsSecPerClustShift;	/* log2 of sectors per cluster */
    u_int8_t bsFATs;			/* number of FATs */
    u_int8_t bsDriveSelect;		/* extended INT 13h drive number */
    u_int8_t bsPercentInUse;		/* percentage of clusters in use */
    u_int8_t bsReserved[7];		/* reserved for future expansion */
    u_int8_t bsBootCode[390];		/* pad so structure is 512b */
    u_int8_t bsBootSectSig[2];		/* DOSMAGIC */
} __packed;

struct de {
    u_int8_t deName[11];		/* name and extension */
    u_int8_t deAttributes;		/* attributes */
    u_int8_t rsvd[10];			/* reserved */
    u_int8_t deMTime[2];		/* last-modified time */
    u_int8_t deMDate[2];		/* last-modified date */
    u_int8_t deStartCluster[2];		/* starting cluster */
    u_int8_t deFileSize[4];		/* size */
} __packed;

struct bpb {
    u_int bpbBytesPerSec;		/* bytes per sector */
    u_int bpbSecPerClust;		/* sectors per cluster */
    u_int bpbResSectors;		/* reserved sectors */
    u_int bpbFATs;			/* number of FATs */
    u_int bpbRootDirEnts;		/* root directory entries */
    u_int bpbSectors;			/* total sectors */
    u_int bpbMedia;			/* media descriptor */
    u_int bpbFATsecs;			/* sectors per FAT */
    u_int bpbSecPerTrack;		/* sectors per track */
    u_int bpbHeads;			/* drive heads */
    u_int bpbHiddenSecs;		/* hidden sectors */
    u_quad_t bpbHugeSectors; 		/* big total sectors */
    u_int bpbBigFATsecs; 		/* big sectors per FAT */
    u_int bpbRootClust; 		/* root directory start cluster */
    u_int bpbFSInfo; 			/* file system info sector */
    u_int bpbBackup; 			/* backup boot sector */
    u_int bpbUsedBitmapClust1;		/* used block bitmap cluster 1 */
    u_int bpbUsedBitmapClust2;		/* used block bitmap cluster 2 */
    u_int bpbUpcaseTableClust;		/* upcase table cluster */
    u_int bpbClusterHeapOffset;		/* start of EXFAT data area */
    u_int bpbBPSshift;			/* bytes per sector shift value */
    u_int bpbSPCshift;			/* sectors per cluster shift value */
    u_int bpbClusterCount;		/* number of clusters */
    u_int bpbUpcaseTableSectors;	/* upcase table sectors */
    u_int bpbUsedBitmapSectors;		/* used block bitmap sectors */
};

/*
 * Structure of an EXFAT allocation bitmap (cluster heap) entry.
 */
struct exfatdir_bitmap {
	uint8_t		type;		/* entry type == 0x81 */
	uint8_t		flags;		/* secondary flags */
#define	EX_FLAG_BITMAP2		0x01	/* entry is pointing to 2nd bitmap */
	uint8_t		reserved[18];
	uint8_t		firstcluster[4];/* first bitmap cluster */
	uint8_t		datalength[8];	/* size of bitmap in bytes */
};

/*
 * Structure of an EXFAT UTF-16 upper case translation table  entry.
 */
struct exfatdir_upcasetable {
	uint8_t		type;		/* entry type == 0x82 */
	uint8_t		reserved1[3];
	uint8_t		chksum[4];	/* checksum of compressed table */
	uint8_t		reserved2[12];
	uint8_t		firstcluster[4]; /* first bitmap cluster */
	uint8_t		datalength[8]; /* size of bitmap in bytes */
};

/*
 * Structure of an EXFAT volume label entry.
 */
struct exfatdir_label {
	uint8_t		type;		/* entry type == 0x83 */
	uint8_t		namelength;	/* number of UTF-16 characters */
	uint8_t		label[22];	/* up to 11 UTF-16 characters */
	uint8_t		reserved[8];
};

#define	BPBGAP 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

static struct {
    const char *name;
    struct bpb bpb;
} const stdfmt[] = {
    {"160",  {512, 1, 1, 2,  64,  320, 0xfe, 1,  8, 1, BPBGAP}},
    {"180",  {512, 1, 1, 2,  64,  360, 0xfc, 2,  9, 1, BPBGAP}},
    {"320",  {512, 2, 1, 2, 112,  640, 0xff, 1,  8, 2, BPBGAP}},
    {"360",  {512, 2, 1, 2, 112,  720, 0xfd, 2,  9, 2, BPBGAP}},
    {"640",  {512, 2, 1, 2, 112, 1280, 0xfb, 2,  8, 2, BPBGAP}},
    {"720",  {512, 2, 1, 2, 112, 1440, 0xf9, 3,  9, 2, BPBGAP}},
    {"1200", {512, 1, 1, 2, 224, 2400, 0xf9, 7, 15, 2, BPBGAP}},
    {"1232", {1024,1, 1, 2, 192, 1232, 0xfe, 2,  8, 2, BPBGAP}},
    {"1440", {512, 1, 1, 2, 224, 2880, 0xf0, 9, 18, 2, BPBGAP}},
    {"2880", {512, 2, 1, 2, 240, 5760, 0xf0, 9, 36, 2, BPBGAP}}
};

static const u_int8_t bootcode[] = {
    0xfa,			/* cli		    */
    0x31, 0xc0, 		/* xor	   ax,ax    */
    0x8e, 0xd0, 		/* mov	   ss,ax    */
    0xbc, 0x00, 0x7c,		/* mov	   sp,7c00h */
    0xfb,			/* sti		    */
    0x8e, 0xd8, 		/* mov	   ds,ax    */
    0xe8, 0x00, 0x00,		/* call    $ + 3    */
    0x5e,			/* pop	   si	    */
    0x83, 0xc6, 0x19,		/* add	   si,+19h  */
    0xbb, 0x07, 0x00,		/* mov	   bx,0007h */
    0xfc,			/* cld		    */
    0xac,			/* lodsb	    */
    0x84, 0xc0, 		/* test    al,al    */
    0x74, 0x06, 		/* jz	   $ + 8    */
    0xb4, 0x0e, 		/* mov	   ah,0eh   */
    0xcd, 0x10, 		/* int	   10h	    */
    0xeb, 0xf5, 		/* jmp	   $ - 9    */
    0x30, 0xe4, 		/* xor	   ah,ah    */
    0xcd, 0x16, 		/* int	   16h	    */
    0xcd, 0x19, 		/* int	   19h	    */
    0x0d, 0x0a,
    'N', 'o', 'n', '-', 's', 'y', 's', 't',
    'e', 'm', ' ', 'd', 'i', 's', 'k',
    0x0d, 0x0a,
    'P', 'r', 'e', 's', 's', ' ', 'a', 'n',
    'y', ' ', 'k', 'e', 'y', ' ', 't', 'o',
    ' ', 'r', 'e', 'b', 'o', 'o', 't',
    0x0d, 0x0a,
    0
};

/*
 * Up-case table recommended in section 7.2.5.1 of the exFAT File System
 * Specification.
 */
static u_int compr_upcase_table_cksum = 0xE619D30D;

static uint8_t compr_upcase_table[] = {
	0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00,
	0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00,
	0x08, 0x00, 0x09, 0x00, 0x0A, 0x00, 0x0B, 0x00,
	0x0C, 0x00, 0x0D, 0x00, 0x0E, 0x00, 0x0F, 0x00,
	0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00,
	0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17, 0x00,
	0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00,
	0x1C, 0x00, 0x1D, 0x00, 0x1E, 0x00, 0x1F, 0x00,
	0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00,
	0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27, 0x00,
	0x28, 0x00, 0x29, 0x00, 0x2A, 0x00, 0x2B, 0x00,
	0x2C, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x2F, 0x00,
	0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00,
	0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00,
	0x38, 0x00, 0x39, 0x00, 0x3A, 0x00, 0x3B, 0x00,
	0x3C, 0x00, 0x3D, 0x00, 0x3E, 0x00, 0x3F, 0x00,
	0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00,
	0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00,
	0x48, 0x00, 0x49, 0x00, 0x4A, 0x00, 0x4B, 0x00,
	0x4C, 0x00, 0x4D, 0x00, 0x4E, 0x00, 0x4F, 0x00,
	0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00,
	0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00,
	0x58, 0x00, 0x59, 0x00, 0x5A, 0x00, 0x5B, 0x00,
	0x5C, 0x00, 0x5D, 0x00, 0x5E, 0x00, 0x5F, 0x00,
	0x60, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00,
	0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00,
	0x48, 0x00, 0x49, 0x00, 0x4A, 0x00, 0x4B, 0x00,
	0x4C, 0x00, 0x4D, 0x00, 0x4E, 0x00, 0x4F, 0x00,
	0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00,
	0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00,
	0x58, 0x00, 0x59, 0x00, 0x5A, 0x00, 0x7B, 0x00,
	0x7C, 0x00, 0x7D, 0x00, 0x7E, 0x00, 0x7F, 0x00,
	0x80, 0x00, 0x81, 0x00, 0x82, 0x00, 0x83, 0x00,
	0x84, 0x00, 0x85, 0x00, 0x86, 0x00, 0x87, 0x00,
	0x88, 0x00, 0x89, 0x00, 0x8A, 0x00, 0x8B, 0x00,
	0x8C, 0x00, 0x8D, 0x00, 0x8E, 0x00, 0x8F, 0x00,
	0x90, 0x00, 0x91, 0x00, 0x92, 0x00, 0x93, 0x00,
	0x94, 0x00, 0x95, 0x00, 0x96, 0x00, 0x97, 0x00,
	0x98, 0x00, 0x99, 0x00, 0x9A, 0x00, 0x9B, 0x00,
	0x9C, 0x00, 0x9D, 0x00, 0x9E, 0x00, 0x9F, 0x00,
	0xA0, 0x00, 0xA1, 0x00, 0xA2, 0x00, 0xA3, 0x00,
	0xA4, 0x00, 0xA5, 0x00, 0xA6, 0x00, 0xA7, 0x00,
	0xA8, 0x00, 0xA9, 0x00, 0xAA, 0x00, 0xAB, 0x00,
	0xAC, 0x00, 0xAD, 0x00, 0xAE, 0x00, 0xAF, 0x00,
	0xB0, 0x00, 0xB1, 0x00, 0xB2, 0x00, 0xB3, 0x00,
	0xB4, 0x00, 0xB5, 0x00, 0xB6, 0x00, 0xB7, 0x00,
	0xB8, 0x00, 0xB9, 0x00, 0xBA, 0x00, 0xBB, 0x00,
	0xBC, 0x00, 0xBD, 0x00, 0xBE, 0x00, 0xBF, 0x00,
	0xC0, 0x00, 0xC1, 0x00, 0xC2, 0x00, 0xC3, 0x00,
	0xC4, 0x00, 0xC5, 0x00, 0xC6, 0x00, 0xC7, 0x00,
	0xC8, 0x00, 0xC9, 0x00, 0xCA, 0x00, 0xCB, 0x00,
	0xCC, 0x00, 0xCD, 0x00, 0xCE, 0x00, 0xCF, 0x00,
	0xD0, 0x00, 0xD1, 0x00, 0xD2, 0x00, 0xD3, 0x00,
	0xD4, 0x00, 0xD5, 0x00, 0xD6, 0x00, 0xD7, 0x00,
	0xD8, 0x00, 0xD9, 0x00, 0xDA, 0x00, 0xDB, 0x00,
	0xDC, 0x00, 0xDD, 0x00, 0xDE, 0x00, 0xDF, 0x00,
	0xC0, 0x00, 0xC1, 0x00, 0xC2, 0x00, 0xC3, 0x00,
	0xC4, 0x00, 0xC5, 0x00, 0xC6, 0x00, 0xC7, 0x00,
	0xC8, 0x00, 0xC9, 0x00, 0xCA, 0x00, 0xCB, 0x00,
	0xCC, 0x00, 0xCD, 0x00, 0xCE, 0x00, 0xCF, 0x00,
	0xD0, 0x00, 0xD1, 0x00, 0xD2, 0x00, 0xD3, 0x00,
	0xD4, 0x00, 0xD5, 0x00, 0xD6, 0x00, 0xF7, 0x00,
	0xD8, 0x00, 0xD9, 0x00, 0xDA, 0x00, 0xDB, 0x00,
	0xDC, 0x00, 0xDD, 0x00, 0xDE, 0x00, 0x78, 0x01,
	0x00, 0x01, 0x00, 0x01, 0x02, 0x01, 0x02, 0x01,
	0x04, 0x01, 0x04, 0x01, 0x06, 0x01, 0x06, 0x01,
	0x08, 0x01, 0x08, 0x01, 0x0A, 0x01, 0x0A, 0x01,
	0x0C, 0x01, 0x0C, 0x01, 0x0E, 0x01, 0x0E, 0x01,
	0x10, 0x01, 0x10, 0x01, 0x12, 0x01, 0x12, 0x01,
	0x14, 0x01, 0x14, 0x01, 0x16, 0x01, 0x16, 0x01,
	0x18, 0x01, 0x18, 0x01, 0x1A, 0x01, 0x1A, 0x01,
	0x1C, 0x01, 0x1C, 0x01, 0x1E, 0x01, 0x1E, 0x01,
	0x20, 0x01, 0x20, 0x01, 0x22, 0x01, 0x22, 0x01,
	0x24, 0x01, 0x24, 0x01, 0x26, 0x01, 0x26, 0x01,
	0x28, 0x01, 0x28, 0x01, 0x2A, 0x01, 0x2A, 0x01,
	0x2C, 0x01, 0x2C, 0x01, 0x2E, 0x01, 0x2E, 0x01,
	0x30, 0x01, 0x31, 0x01, 0x32, 0x01, 0x32, 0x01,
	0x34, 0x01, 0x34, 0x01, 0x36, 0x01, 0x36, 0x01,
	0x38, 0x01, 0x39, 0x01, 0x39, 0x01, 0x3B, 0x01,
	0x3B, 0x01, 0x3D, 0x01, 0x3D, 0x01, 0x3F, 0x01,
	0x3F, 0x01, 0x41, 0x01, 0x41, 0x01, 0x43, 0x01,
	0x43, 0x01, 0x45, 0x01, 0x45, 0x01, 0x47, 0x01,
	0x47, 0x01, 0x49, 0x01, 0x4A, 0x01, 0x4A, 0x01,
	0x4C, 0x01, 0x4C, 0x01, 0x4E, 0x01, 0x4E, 0x01,
	0x50, 0x01, 0x50, 0x01, 0x52, 0x01, 0x52, 0x01,
	0x54, 0x01, 0x54, 0x01, 0x56, 0x01, 0x56, 0x01,
	0x58, 0x01, 0x58, 0x01, 0x5A, 0x01, 0x5A, 0x01,
	0x5C, 0x01, 0x5C, 0x01, 0x5E, 0x01, 0x5E, 0x01,
	0x60, 0x01, 0x60, 0x01, 0x62, 0x01, 0x62, 0x01,
	0x64, 0x01, 0x64, 0x01, 0x66, 0x01, 0x66, 0x01,
	0x68, 0x01, 0x68, 0x01, 0x6A, 0x01, 0x6A, 0x01,
	0x6C, 0x01, 0x6C, 0x01, 0x6E, 0x01, 0x6E, 0x01,
	0x70, 0x01, 0x70, 0x01, 0x72, 0x01, 0x72, 0x01,
	0x74, 0x01, 0x74, 0x01, 0x76, 0x01, 0x76, 0x01,
	0x78, 0x01, 0x79, 0x01, 0x79, 0x01, 0x7B, 0x01,
	0x7B, 0x01, 0x7D, 0x01, 0x7D, 0x01, 0x7F, 0x01,
	0x43, 0x02, 0x81, 0x01, 0x82, 0x01, 0x82, 0x01,
	0x84, 0x01, 0x84, 0x01, 0x86, 0x01, 0x87, 0x01,
	0x87, 0x01, 0x89, 0x01, 0x8A, 0x01, 0x8B, 0x01,
	0x8B, 0x01, 0x8D, 0x01, 0x8E, 0x01, 0x8F, 0x01,
	0x90, 0x01, 0x91, 0x01, 0x91, 0x01, 0x93, 0x01,
	0x94, 0x01, 0xF6, 0x01, 0x96, 0x01, 0x97, 0x01,
	0x98, 0x01, 0x98, 0x01, 0x3D, 0x02, 0x9B, 0x01,
	0x9C, 0x01, 0x9D, 0x01, 0x20, 0x02, 0x9F, 0x01,
	0xA0, 0x01, 0xA0, 0x01, 0xA2, 0x01, 0xA2, 0x01,
	0xA4, 0x01, 0xA4, 0x01, 0xA6, 0x01, 0xA7, 0x01,
	0xA7, 0x01, 0xA9, 0x01, 0xAA, 0x01, 0xAB, 0x01,
	0xAC, 0x01, 0xAC, 0x01, 0xAE, 0x01, 0xAF, 0x01,
	0xAF, 0x01, 0xB1, 0x01, 0xB2, 0x01, 0xB3, 0x01,
	0xB3, 0x01, 0xB5, 0x01, 0xB5, 0x01, 0xB7, 0x01,
	0xB8, 0x01, 0xB8, 0x01, 0xBA, 0x01, 0xBB, 0x01,
	0xBC, 0x01, 0xBC, 0x01, 0xBE, 0x01, 0xF7, 0x01,
	0xC0, 0x01, 0xC1, 0x01, 0xC2, 0x01, 0xC3, 0x01,
	0xC4, 0x01, 0xC5, 0x01, 0xC4, 0x01, 0xC7, 0x01,
	0xC8, 0x01, 0xC7, 0x01, 0xCA, 0x01, 0xCB, 0x01,
	0xCA, 0x01, 0xCD, 0x01, 0xCD, 0x01, 0xCF, 0x01,
	0xCF, 0x01, 0xD1, 0x01, 0xD1, 0x01, 0xD3, 0x01,
	0xD3, 0x01, 0xD5, 0x01, 0xD5, 0x01, 0xD7, 0x01,
	0xD7, 0x01, 0xD9, 0x01, 0xD9, 0x01, 0xDB, 0x01,
	0xDB, 0x01, 0x8E, 0x01, 0xDE, 0x01, 0xDE, 0x01,
	0xE0, 0x01, 0xE0, 0x01, 0xE2, 0x01, 0xE2, 0x01,
	0xE4, 0x01, 0xE4, 0x01, 0xE6, 0x01, 0xE6, 0x01,
	0xE8, 0x01, 0xE8, 0x01, 0xEA, 0x01, 0xEA, 0x01,
	0xEC, 0x01, 0xEC, 0x01, 0xEE, 0x01, 0xEE, 0x01,
	0xF0, 0x01, 0xF1, 0x01, 0xF2, 0x01, 0xF1, 0x01,
	0xF4, 0x01, 0xF4, 0x01, 0xF6, 0x01, 0xF7, 0x01,
	0xF8, 0x01, 0xF8, 0x01, 0xFA, 0x01, 0xFA, 0x01,
	0xFC, 0x01, 0xFC, 0x01, 0xFE, 0x01, 0xFE, 0x01,
	0x00, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x04, 0x02, 0x04, 0x02, 0x06, 0x02, 0x06, 0x02,
	0x08, 0x02, 0x08, 0x02, 0x0A, 0x02, 0x0A, 0x02,
	0x0C, 0x02, 0x0C, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x10, 0x02, 0x10, 0x02, 0x12, 0x02, 0x12, 0x02,
	0x14, 0x02, 0x14, 0x02, 0x16, 0x02, 0x16, 0x02,
	0x18, 0x02, 0x18, 0x02, 0x1A, 0x02, 0x1A, 0x02,
	0x1C, 0x02, 0x1C, 0x02, 0x1E, 0x02, 0x1E, 0x02,
	0x20, 0x02, 0x21, 0x02, 0x22, 0x02, 0x22, 0x02,
	0x24, 0x02, 0x24, 0x02, 0x26, 0x02, 0x26, 0x02,
	0x28, 0x02, 0x28, 0x02, 0x2A, 0x02, 0x2A, 0x02,
	0x2C, 0x02, 0x2C, 0x02, 0x2E, 0x02, 0x2E, 0x02,
	0x30, 0x02, 0x30, 0x02, 0x32, 0x02, 0x32, 0x02,
	0x34, 0x02, 0x35, 0x02, 0x36, 0x02, 0x37, 0x02,
	0x38, 0x02, 0x39, 0x02, 0x65, 0x2C, 0x3B, 0x02,
	0x3B, 0x02, 0x3D, 0x02, 0x66, 0x2C, 0x3F, 0x02,
	0x40, 0x02, 0x41, 0x02, 0x41, 0x02, 0x43, 0x02,
	0x44, 0x02, 0x45, 0x02, 0x46, 0x02, 0x46, 0x02,
	0x48, 0x02, 0x48, 0x02, 0x4A, 0x02, 0x4A, 0x02,
	0x4C, 0x02, 0x4C, 0x02, 0x4E, 0x02, 0x4E, 0x02,
	0x50, 0x02, 0x51, 0x02, 0x52, 0x02, 0x81, 0x01,
	0x86, 0x01, 0x55, 0x02, 0x89, 0x01, 0x8A, 0x01,
	0x58, 0x02, 0x8F, 0x01, 0x5A, 0x02, 0x90, 0x01,
	0x5C, 0x02, 0x5D, 0x02, 0x5E, 0x02, 0x5F, 0x02,
	0x93, 0x01, 0x61, 0x02, 0x62, 0x02, 0x94, 0x01,
	0x64, 0x02, 0x65, 0x02, 0x66, 0x02, 0x67, 0x02,
	0x97, 0x01, 0x96, 0x01, 0x6A, 0x02, 0x62, 0x2C,
	0x6C, 0x02, 0x6D, 0x02, 0x6E, 0x02, 0x9C, 0x01,
	0x70, 0x02, 0x71, 0x02, 0x9D, 0x01, 0x73, 0x02,
	0x74, 0x02, 0x9F, 0x01, 0x76, 0x02, 0x77, 0x02,
	0x78, 0x02, 0x79, 0x02, 0x7A, 0x02, 0x7B, 0x02,
	0x7C, 0x02, 0x64, 0x2C, 0x7E, 0x02, 0x7F, 0x02,
	0xA6, 0x01, 0x81, 0x02, 0x82, 0x02, 0xA9, 0x01,
	0x84, 0x02, 0x85, 0x02, 0x86, 0x02, 0x87, 0x02,
	0xAE, 0x01, 0x44, 0x02, 0xB1, 0x01, 0xB2, 0x01,
	0x45, 0x02, 0x8D, 0x02, 0x8E, 0x02, 0x8F, 0x02,
	0x90, 0x02, 0x91, 0x02, 0xB7, 0x01, 0x93, 0x02,
	0x94, 0x02, 0x95, 0x02, 0x96, 0x02, 0x97, 0x02,
	0x98, 0x02, 0x99, 0x02, 0x9A, 0x02, 0x9B, 0x02,
	0x9C, 0x02, 0x9D, 0x02, 0x9E, 0x02, 0x9F, 0x02,
	0xA0, 0x02, 0xA1, 0x02, 0xA2, 0x02, 0xA3, 0x02,
	0xA4, 0x02, 0xA5, 0x02, 0xA6, 0x02, 0xA7, 0x02,
	0xA8, 0x02, 0xA9, 0x02, 0xAA, 0x02, 0xAB, 0x02,
	0xAC, 0x02, 0xAD, 0x02, 0xAE, 0x02, 0xAF, 0x02,
	0xB0, 0x02, 0xB1, 0x02, 0xB2, 0x02, 0xB3, 0x02,
	0xB4, 0x02, 0xB5, 0x02, 0xB6, 0x02, 0xB7, 0x02,
	0xB8, 0x02, 0xB9, 0x02, 0xBA, 0x02, 0xBB, 0x02,
	0xBC, 0x02, 0xBD, 0x02, 0xBE, 0x02, 0xBF, 0x02,
	0xC0, 0x02, 0xC1, 0x02, 0xC2, 0x02, 0xC3, 0x02,
	0xC4, 0x02, 0xC5, 0x02, 0xC6, 0x02, 0xC7, 0x02,
	0xC8, 0x02, 0xC9, 0x02, 0xCA, 0x02, 0xCB, 0x02,
	0xCC, 0x02, 0xCD, 0x02, 0xCE, 0x02, 0xCF, 0x02,
	0xD0, 0x02, 0xD1, 0x02, 0xD2, 0x02, 0xD3, 0x02,
	0xD4, 0x02, 0xD5, 0x02, 0xD6, 0x02, 0xD7, 0x02,
	0xD8, 0x02, 0xD9, 0x02, 0xDA, 0x02, 0xDB, 0x02,
	0xDC, 0x02, 0xDD, 0x02, 0xDE, 0x02, 0xDF, 0x02,
	0xE0, 0x02, 0xE1, 0x02, 0xE2, 0x02, 0xE3, 0x02,
	0xE4, 0x02, 0xE5, 0x02, 0xE6, 0x02, 0xE7, 0x02,
	0xE8, 0x02, 0xE9, 0x02, 0xEA, 0x02, 0xEB, 0x02,
	0xEC, 0x02, 0xED, 0x02, 0xEE, 0x02, 0xEF, 0x02,
	0xF0, 0x02, 0xF1, 0x02, 0xF2, 0x02, 0xF3, 0x02,
	0xF4, 0x02, 0xF5, 0x02, 0xF6, 0x02, 0xF7, 0x02,
	0xF8, 0x02, 0xF9, 0x02, 0xFA, 0x02, 0xFB, 0x02,
	0xFC, 0x02, 0xFD, 0x02, 0xFE, 0x02, 0xFF, 0x02,
	0x00, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03,
	0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x07, 0x03,
	0x08, 0x03, 0x09, 0x03, 0x0A, 0x03, 0x0B, 0x03,
	0x0C, 0x03, 0x0D, 0x03, 0x0E, 0x03, 0x0F, 0x03,
	0x10, 0x03, 0x11, 0x03, 0x12, 0x03, 0x13, 0x03,
	0x14, 0x03, 0x15, 0x03, 0x16, 0x03, 0x17, 0x03,
	0x18, 0x03, 0x19, 0x03, 0x1A, 0x03, 0x1B, 0x03,
	0x1C, 0x03, 0x1D, 0x03, 0x1E, 0x03, 0x1F, 0x03,
	0x20, 0x03, 0x21, 0x03, 0x22, 0x03, 0x23, 0x03,
	0x24, 0x03, 0x25, 0x03, 0x26, 0x03, 0x27, 0x03,
	0x28, 0x03, 0x29, 0x03, 0x2A, 0x03, 0x2B, 0x03,
	0x2C, 0x03, 0x2D, 0x03, 0x2E, 0x03, 0x2F, 0x03,
	0x30, 0x03, 0x31, 0x03, 0x32, 0x03, 0x33, 0x03,
	0x34, 0x03, 0x35, 0x03, 0x36, 0x03, 0x37, 0x03,
	0x38, 0x03, 0x39, 0x03, 0x3A, 0x03, 0x3B, 0x03,
	0x3C, 0x03, 0x3D, 0x03, 0x3E, 0x03, 0x3F, 0x03,
	0x40, 0x03, 0x41, 0x03, 0x42, 0x03, 0x43, 0x03,
	0x44, 0x03, 0x45, 0x03, 0x46, 0x03, 0x47, 0x03,
	0x48, 0x03, 0x49, 0x03, 0x4A, 0x03, 0x4B, 0x03,
	0x4C, 0x03, 0x4D, 0x03, 0x4E, 0x03, 0x4F, 0x03,
	0x50, 0x03, 0x51, 0x03, 0x52, 0x03, 0x53, 0x03,
	0x54, 0x03, 0x55, 0x03, 0x56, 0x03, 0x57, 0x03,
	0x58, 0x03, 0x59, 0x03, 0x5A, 0x03, 0x5B, 0x03,
	0x5C, 0x03, 0x5D, 0x03, 0x5E, 0x03, 0x5F, 0x03,
	0x60, 0x03, 0x61, 0x03, 0x62, 0x03, 0x63, 0x03,
	0x64, 0x03, 0x65, 0x03, 0x66, 0x03, 0x67, 0x03,
	0x68, 0x03, 0x69, 0x03, 0x6A, 0x03, 0x6B, 0x03,
	0x6C, 0x03, 0x6D, 0x03, 0x6E, 0x03, 0x6F, 0x03,
	0x70, 0x03, 0x71, 0x03, 0x72, 0x03, 0x73, 0x03,
	0x74, 0x03, 0x75, 0x03, 0x76, 0x03, 0x77, 0x03,
	0x78, 0x03, 0x79, 0x03, 0x7A, 0x03, 0xFD, 0x03,
	0xFE, 0x03, 0xFF, 0x03, 0x7E, 0x03, 0x7F, 0x03,
	0x80, 0x03, 0x81, 0x03, 0x82, 0x03, 0x83, 0x03,
	0x84, 0x03, 0x85, 0x03, 0x86, 0x03, 0x87, 0x03,
	0x88, 0x03, 0x89, 0x03, 0x8A, 0x03, 0x8B, 0x03,
	0x8C, 0x03, 0x8D, 0x03, 0x8E, 0x03, 0x8F, 0x03,
	0x90, 0x03, 0x91, 0x03, 0x92, 0x03, 0x93, 0x03,
	0x94, 0x03, 0x95, 0x03, 0x96, 0x03, 0x97, 0x03,
	0x98, 0x03, 0x99, 0x03, 0x9A, 0x03, 0x9B, 0x03,
	0x9C, 0x03, 0x9D, 0x03, 0x9E, 0x03, 0x9F, 0x03,
	0xA0, 0x03, 0xA1, 0x03, 0xA2, 0x03, 0xA3, 0x03,
	0xA4, 0x03, 0xA5, 0x03, 0xA6, 0x03, 0xA7, 0x03,
	0xA8, 0x03, 0xA9, 0x03, 0xAA, 0x03, 0xAB, 0x03,
	0x86, 0x03, 0x88, 0x03, 0x89, 0x03, 0x8A, 0x03,
	0xB0, 0x03, 0x91, 0x03, 0x92, 0x03, 0x93, 0x03,
	0x94, 0x03, 0x95, 0x03, 0x96, 0x03, 0x97, 0x03,
	0x98, 0x03, 0x99, 0x03, 0x9A, 0x03, 0x9B, 0x03,
	0x9C, 0x03, 0x9D, 0x03, 0x9E, 0x03, 0x9F, 0x03,
	0xA0, 0x03, 0xA1, 0x03, 0xA3, 0x03, 0xA3, 0x03,
	0xA4, 0x03, 0xA5, 0x03, 0xA6, 0x03, 0xA7, 0x03,
	0xA8, 0x03, 0xA9, 0x03, 0xAA, 0x03, 0xAB, 0x03,
	0x8C, 0x03, 0x8E, 0x03, 0x8F, 0x03, 0xCF, 0x03,
	0xD0, 0x03, 0xD1, 0x03, 0xD2, 0x03, 0xD3, 0x03,
	0xD4, 0x03, 0xD5, 0x03, 0xD6, 0x03, 0xD7, 0x03,
	0xD8, 0x03, 0xD8, 0x03, 0xDA, 0x03, 0xDA, 0x03,
	0xDC, 0x03, 0xDC, 0x03, 0xDE, 0x03, 0xDE, 0x03,
	0xE0, 0x03, 0xE0, 0x03, 0xE2, 0x03, 0xE2, 0x03,
	0xE4, 0x03, 0xE4, 0x03, 0xE6, 0x03, 0xE6, 0x03,
	0xE8, 0x03, 0xE8, 0x03, 0xEA, 0x03, 0xEA, 0x03,
	0xEC, 0x03, 0xEC, 0x03, 0xEE, 0x03, 0xEE, 0x03,
	0xF0, 0x03, 0xF1, 0x03, 0xF9, 0x03, 0xF3, 0x03,
	0xF4, 0x03, 0xF5, 0x03, 0xF6, 0x03, 0xF7, 0x03,
	0xF7, 0x03, 0xF9, 0x03, 0xFA, 0x03, 0xFA, 0x03,
	0xFC, 0x03, 0xFD, 0x03, 0xFE, 0x03, 0xFF, 0x03,
	0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x04,
	0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07, 0x04,
	0x08, 0x04, 0x09, 0x04, 0x0A, 0x04, 0x0B, 0x04,
	0x0C, 0x04, 0x0D, 0x04, 0x0E, 0x04, 0x0F, 0x04,
	0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13, 0x04,
	0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17, 0x04,
	0x18, 0x04, 0x19, 0x04, 0x1A, 0x04, 0x1B, 0x04,
	0x1C, 0x04, 0x1D, 0x04, 0x1E, 0x04, 0x1F, 0x04,
	0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23, 0x04,
	0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27, 0x04,
	0x28, 0x04, 0x29, 0x04, 0x2A, 0x04, 0x2B, 0x04,
	0x2C, 0x04, 0x2D, 0x04, 0x2E, 0x04, 0x2F, 0x04,
	0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13, 0x04,
	0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17, 0x04,
	0x18, 0x04, 0x19, 0x04, 0x1A, 0x04, 0x1B, 0x04,
	0x1C, 0x04, 0x1D, 0x04, 0x1E, 0x04, 0x1F, 0x04,
	0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23, 0x04,
	0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27, 0x04,
	0x28, 0x04, 0x29, 0x04, 0x2A, 0x04, 0x2B, 0x04,
	0x2C, 0x04, 0x2D, 0x04, 0x2E, 0x04, 0x2F, 0x04,
	0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x04,
	0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07, 0x04,
	0x08, 0x04, 0x09, 0x04, 0x0A, 0x04, 0x0B, 0x04,
	0x0C, 0x04, 0x0D, 0x04, 0x0E, 0x04, 0x0F, 0x04,
	0x60, 0x04, 0x60, 0x04, 0x62, 0x04, 0x62, 0x04,
	0x64, 0x04, 0x64, 0x04, 0x66, 0x04, 0x66, 0x04,
	0x68, 0x04, 0x68, 0x04, 0x6A, 0x04, 0x6A, 0x04,
	0x6C, 0x04, 0x6C, 0x04, 0x6E, 0x04, 0x6E, 0x04,
	0x70, 0x04, 0x70, 0x04, 0x72, 0x04, 0x72, 0x04,
	0x74, 0x04, 0x74, 0x04, 0x76, 0x04, 0x76, 0x04,
	0x78, 0x04, 0x78, 0x04, 0x7A, 0x04, 0x7A, 0x04,
	0x7C, 0x04, 0x7C, 0x04, 0x7E, 0x04, 0x7E, 0x04,
	0x80, 0x04, 0x80, 0x04, 0x82, 0x04, 0x83, 0x04,
	0x84, 0x04, 0x85, 0x04, 0x86, 0x04, 0x87, 0x04,
	0x88, 0x04, 0x89, 0x04, 0x8A, 0x04, 0x8A, 0x04,
	0x8C, 0x04, 0x8C, 0x04, 0x8E, 0x04, 0x8E, 0x04,
	0x90, 0x04, 0x90, 0x04, 0x92, 0x04, 0x92, 0x04,
	0x94, 0x04, 0x94, 0x04, 0x96, 0x04, 0x96, 0x04,
	0x98, 0x04, 0x98, 0x04, 0x9A, 0x04, 0x9A, 0x04,
	0x9C, 0x04, 0x9C, 0x04, 0x9E, 0x04, 0x9E, 0x04,
	0xA0, 0x04, 0xA0, 0x04, 0xA2, 0x04, 0xA2, 0x04,
	0xA4, 0x04, 0xA4, 0x04, 0xA6, 0x04, 0xA6, 0x04,
	0xA8, 0x04, 0xA8, 0x04, 0xAA, 0x04, 0xAA, 0x04,
	0xAC, 0x04, 0xAC, 0x04, 0xAE, 0x04, 0xAE, 0x04,
	0xB0, 0x04, 0xB0, 0x04, 0xB2, 0x04, 0xB2, 0x04,
	0xB4, 0x04, 0xB4, 0x04, 0xB6, 0x04, 0xB6, 0x04,
	0xB8, 0x04, 0xB8, 0x04, 0xBA, 0x04, 0xBA, 0x04,
	0xBC, 0x04, 0xBC, 0x04, 0xBE, 0x04, 0xBE, 0x04,
	0xC0, 0x04, 0xC1, 0x04, 0xC1, 0x04, 0xC3, 0x04,
	0xC3, 0x04, 0xC5, 0x04, 0xC5, 0x04, 0xC7, 0x04,
	0xC7, 0x04, 0xC9, 0x04, 0xC9, 0x04, 0xCB, 0x04,
	0xCB, 0x04, 0xCD, 0x04, 0xCD, 0x04, 0xC0, 0x04,
	0xD0, 0x04, 0xD0, 0x04, 0xD2, 0x04, 0xD2, 0x04,
	0xD4, 0x04, 0xD4, 0x04, 0xD6, 0x04, 0xD6, 0x04,
	0xD8, 0x04, 0xD8, 0x04, 0xDA, 0x04, 0xDA, 0x04,
	0xDC, 0x04, 0xDC, 0x04, 0xDE, 0x04, 0xDE, 0x04,
	0xE0, 0x04, 0xE0, 0x04, 0xE2, 0x04, 0xE2, 0x04,
	0xE4, 0x04, 0xE4, 0x04, 0xE6, 0x04, 0xE6, 0x04,
	0xE8, 0x04, 0xE8, 0x04, 0xEA, 0x04, 0xEA, 0x04,
	0xEC, 0x04, 0xEC, 0x04, 0xEE, 0x04, 0xEE, 0x04,
	0xF0, 0x04, 0xF0, 0x04, 0xF2, 0x04, 0xF2, 0x04,
	0xF4, 0x04, 0xF4, 0x04, 0xF6, 0x04, 0xF6, 0x04,
	0xF8, 0x04, 0xF8, 0x04, 0xFA, 0x04, 0xFA, 0x04,
	0xFC, 0x04, 0xFC, 0x04, 0xFE, 0x04, 0xFE, 0x04,
	0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 0x02, 0x05,
	0x04, 0x05, 0x04, 0x05, 0x06, 0x05, 0x06, 0x05,
	0x08, 0x05, 0x08, 0x05, 0x0A, 0x05, 0x0A, 0x05,
	0x0C, 0x05, 0x0C, 0x05, 0x0E, 0x05, 0x0E, 0x05,
	0x10, 0x05, 0x10, 0x05, 0x12, 0x05, 0x12, 0x05,
	0x14, 0x05, 0x15, 0x05, 0x16, 0x05, 0x17, 0x05,
	0x18, 0x05, 0x19, 0x05, 0x1A, 0x05, 0x1B, 0x05,
	0x1C, 0x05, 0x1D, 0x05, 0x1E, 0x05, 0x1F, 0x05,
	0x20, 0x05, 0x21, 0x05, 0x22, 0x05, 0x23, 0x05,
	0x24, 0x05, 0x25, 0x05, 0x26, 0x05, 0x27, 0x05,
	0x28, 0x05, 0x29, 0x05, 0x2A, 0x05, 0x2B, 0x05,
	0x2C, 0x05, 0x2D, 0x05, 0x2E, 0x05, 0x2F, 0x05,
	0x30, 0x05, 0x31, 0x05, 0x32, 0x05, 0x33, 0x05,
	0x34, 0x05, 0x35, 0x05, 0x36, 0x05, 0x37, 0x05,
	0x38, 0x05, 0x39, 0x05, 0x3A, 0x05, 0x3B, 0x05,
	0x3C, 0x05, 0x3D, 0x05, 0x3E, 0x05, 0x3F, 0x05,
	0x40, 0x05, 0x41, 0x05, 0x42, 0x05, 0x43, 0x05,
	0x44, 0x05, 0x45, 0x05, 0x46, 0x05, 0x47, 0x05,
	0x48, 0x05, 0x49, 0x05, 0x4A, 0x05, 0x4B, 0x05,
	0x4C, 0x05, 0x4D, 0x05, 0x4E, 0x05, 0x4F, 0x05,
	0x50, 0x05, 0x51, 0x05, 0x52, 0x05, 0x53, 0x05,
	0x54, 0x05, 0x55, 0x05, 0x56, 0x05, 0x57, 0x05,
	0x58, 0x05, 0x59, 0x05, 0x5A, 0x05, 0x5B, 0x05,
	0x5C, 0x05, 0x5D, 0x05, 0x5E, 0x05, 0x5F, 0x05,
	0x60, 0x05, 0x31, 0x05, 0x32, 0x05, 0x33, 0x05,
	0x34, 0x05, 0x35, 0x05, 0x36, 0x05, 0x37, 0x05,
	0x38, 0x05, 0x39, 0x05, 0x3A, 0x05, 0x3B, 0x05,
	0x3C, 0x05, 0x3D, 0x05, 0x3E, 0x05, 0x3F, 0x05,
	0x40, 0x05, 0x41, 0x05, 0x42, 0x05, 0x43, 0x05,
	0x44, 0x05, 0x45, 0x05, 0x46, 0x05, 0x47, 0x05,
	0x48, 0x05, 0x49, 0x05, 0x4A, 0x05, 0x4B, 0x05,
	0x4C, 0x05, 0x4D, 0x05, 0x4E, 0x05, 0x4F, 0x05,
	0x50, 0x05, 0x51, 0x05, 0x52, 0x05, 0x53, 0x05,
	0x54, 0x05, 0x55, 0x05, 0x56, 0x05, 0xFF, 0xFF,
	0xF6, 0x17, 0x63, 0x2C, 0x7E, 0x1D, 0x7F, 0x1D,
	0x80, 0x1D, 0x81, 0x1D, 0x82, 0x1D, 0x83, 0x1D,
	0x84, 0x1D, 0x85, 0x1D, 0x86, 0x1D, 0x87, 0x1D,
	0x88, 0x1D, 0x89, 0x1D, 0x8A, 0x1D, 0x8B, 0x1D,
	0x8C, 0x1D, 0x8D, 0x1D, 0x8E, 0x1D, 0x8F, 0x1D,
	0x90, 0x1D, 0x91, 0x1D, 0x92, 0x1D, 0x93, 0x1D,
	0x94, 0x1D, 0x95, 0x1D, 0x96, 0x1D, 0x97, 0x1D,
	0x98, 0x1D, 0x99, 0x1D, 0x9A, 0x1D, 0x9B, 0x1D,
	0x9C, 0x1D, 0x9D, 0x1D, 0x9E, 0x1D, 0x9F, 0x1D,
	0xA0, 0x1D, 0xA1, 0x1D, 0xA2, 0x1D, 0xA3, 0x1D,
	0xA4, 0x1D, 0xA5, 0x1D, 0xA6, 0x1D, 0xA7, 0x1D,
	0xA8, 0x1D, 0xA9, 0x1D, 0xAA, 0x1D, 0xAB, 0x1D,
	0xAC, 0x1D, 0xAD, 0x1D, 0xAE, 0x1D, 0xAF, 0x1D,
	0xB0, 0x1D, 0xB1, 0x1D, 0xB2, 0x1D, 0xB3, 0x1D,
	0xB4, 0x1D, 0xB5, 0x1D, 0xB6, 0x1D, 0xB7, 0x1D,
	0xB8, 0x1D, 0xB9, 0x1D, 0xBA, 0x1D, 0xBB, 0x1D,
	0xBC, 0x1D, 0xBD, 0x1D, 0xBE, 0x1D, 0xBF, 0x1D,
	0xC0, 0x1D, 0xC1, 0x1D, 0xC2, 0x1D, 0xC3, 0x1D,
	0xC4, 0x1D, 0xC5, 0x1D, 0xC6, 0x1D, 0xC7, 0x1D,
	0xC8, 0x1D, 0xC9, 0x1D, 0xCA, 0x1D, 0xCB, 0x1D,
	0xCC, 0x1D, 0xCD, 0x1D, 0xCE, 0x1D, 0xCF, 0x1D,
	0xD0, 0x1D, 0xD1, 0x1D, 0xD2, 0x1D, 0xD3, 0x1D,
	0xD4, 0x1D, 0xD5, 0x1D, 0xD6, 0x1D, 0xD7, 0x1D,
	0xD8, 0x1D, 0xD9, 0x1D, 0xDA, 0x1D, 0xDB, 0x1D,
	0xDC, 0x1D, 0xDD, 0x1D, 0xDE, 0x1D, 0xDF, 0x1D,
	0xE0, 0x1D, 0xE1, 0x1D, 0xE2, 0x1D, 0xE3, 0x1D,
	0xE4, 0x1D, 0xE5, 0x1D, 0xE6, 0x1D, 0xE7, 0x1D,
	0xE8, 0x1D, 0xE9, 0x1D, 0xEA, 0x1D, 0xEB, 0x1D,
	0xEC, 0x1D, 0xED, 0x1D, 0xEE, 0x1D, 0xEF, 0x1D,
	0xF0, 0x1D, 0xF1, 0x1D, 0xF2, 0x1D, 0xF3, 0x1D,
	0xF4, 0x1D, 0xF5, 0x1D, 0xF6, 0x1D, 0xF7, 0x1D,
	0xF8, 0x1D, 0xF9, 0x1D, 0xFA, 0x1D, 0xFB, 0x1D,
	0xFC, 0x1D, 0xFD, 0x1D, 0xFE, 0x1D, 0xFF, 0x1D,
	0x00, 0x1E, 0x00, 0x1E, 0x02, 0x1E, 0x02, 0x1E,
	0x04, 0x1E, 0x04, 0x1E, 0x06, 0x1E, 0x06, 0x1E,
	0x08, 0x1E, 0x08, 0x1E, 0x0A, 0x1E, 0x0A, 0x1E,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0E, 0x1E, 0x0E, 0x1E,
	0x10, 0x1E, 0x10, 0x1E, 0x12, 0x1E, 0x12, 0x1E,
	0x14, 0x1E, 0x14, 0x1E, 0x16, 0x1E, 0x16, 0x1E,
	0x18, 0x1E, 0x18, 0x1E, 0x1A, 0x1E, 0x1A, 0x1E,
	0x1C, 0x1E, 0x1C, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
	0x20, 0x1E, 0x20, 0x1E, 0x22, 0x1E, 0x22, 0x1E,
	0x24, 0x1E, 0x24, 0x1E, 0x26, 0x1E, 0x26, 0x1E,
	0x28, 0x1E, 0x28, 0x1E, 0x2A, 0x1E, 0x2A, 0x1E,
	0x2C, 0x1E, 0x2C, 0x1E, 0x2E, 0x1E, 0x2E, 0x1E,
	0x30, 0x1E, 0x30, 0x1E, 0x32, 0x1E, 0x32, 0x1E,
	0x34, 0x1E, 0x34, 0x1E, 0x36, 0x1E, 0x36, 0x1E,
	0x38, 0x1E, 0x38, 0x1E, 0x3A, 0x1E, 0x3A, 0x1E,
	0x3C, 0x1E, 0x3C, 0x1E, 0x3E, 0x1E, 0x3E, 0x1E,
	0x40, 0x1E, 0x40, 0x1E, 0x42, 0x1E, 0x42, 0x1E,
	0x44, 0x1E, 0x44, 0x1E, 0x46, 0x1E, 0x46, 0x1E,
	0x48, 0x1E, 0x48, 0x1E, 0x4A, 0x1E, 0x4A, 0x1E,
	0x4C, 0x1E, 0x4C, 0x1E, 0x4E, 0x1E, 0x4E, 0x1E,
	0x50, 0x1E, 0x50, 0x1E, 0x52, 0x1E, 0x52, 0x1E,
	0x54, 0x1E, 0x54, 0x1E, 0x56, 0x1E, 0x56, 0x1E,
	0x58, 0x1E, 0x58, 0x1E, 0x5A, 0x1E, 0x5A, 0x1E,
	0x5C, 0x1E, 0x5C, 0x1E, 0x5E, 0x1E, 0x5E, 0x1E,
	0x60, 0x1E, 0x60, 0x1E, 0x62, 0x1E, 0x62, 0x1E,
	0x64, 0x1E, 0x64, 0x1E, 0x66, 0x1E, 0x66, 0x1E,
	0x68, 0x1E, 0x68, 0x1E, 0x6A, 0x1E, 0x6A, 0x1E,
	0x6C, 0x1E, 0x6C, 0x1E, 0x6E, 0x1E, 0x6E, 0x1E,
	0x70, 0x1E, 0x70, 0x1E, 0x72, 0x1E, 0x72, 0x1E,
	0x74, 0x1E, 0x74, 0x1E, 0x76, 0x1E, 0x76, 0x1E,
	0x78, 0x1E, 0x78, 0x1E, 0x7A, 0x1E, 0x7A, 0x1E,
	0x7C, 0x1E, 0x7C, 0x1E, 0x7E, 0x1E, 0x7E, 0x1E,
	0x80, 0x1E, 0x80, 0x1E, 0x82, 0x1E, 0x82, 0x1E,
	0x84, 0x1E, 0x84, 0x1E, 0x86, 0x1E, 0x86, 0x1E,
	0x88, 0x1E, 0x88, 0x1E, 0x8A, 0x1E, 0x8A, 0x1E,
	0x8C, 0x1E, 0x8C, 0x1E, 0x8E, 0x1E, 0x8E, 0x1E,
	0x90, 0x1E, 0x90, 0x1E, 0x92, 0x1E, 0x92, 0x1E,
	0x94, 0x1E, 0x94, 0x1E, 0x96, 0x1E, 0x97, 0x1E,
	0x98, 0x1E, 0x99, 0x1E, 0x9A, 0x1E, 0x9B, 0x1E,
	0x9C, 0x1E, 0x9D, 0x1E, 0x9E, 0x1E, 0x9F, 0x1E,
	0xA0, 0x1E, 0xA0, 0x1E, 0xA2, 0x1E, 0xA2, 0x1E,
	0xA4, 0x1E, 0xA4, 0x1E, 0xA6, 0x1E, 0xA6, 0x1E,
	0xA8, 0x1E, 0xA8, 0x1E, 0xAA, 0x1E, 0xAA, 0x1E,
	0xAC, 0x1E, 0xAC, 0x1E, 0xAE, 0x1E, 0xAE, 0x1E,
	0xB0, 0x1E, 0xB0, 0x1E, 0xB2, 0x1E, 0xB2, 0x1E,
	0xB4, 0x1E, 0xB4, 0x1E, 0xB6, 0x1E, 0xB6, 0x1E,
	0xB8, 0x1E, 0xB8, 0x1E, 0xBA, 0x1E, 0xBA, 0x1E,
	0xBC, 0x1E, 0xBC, 0x1E, 0xBE, 0x1E, 0xBE, 0x1E,
	0xC0, 0x1E, 0xC0, 0x1E, 0xC2, 0x1E, 0xC2, 0x1E,
	0xC4, 0x1E, 0xC4, 0x1E, 0xC6, 0x1E, 0xC6, 0x1E,
	0xC8, 0x1E, 0xC8, 0x1E, 0xCA, 0x1E, 0xCA, 0x1E,
	0xCC, 0x1E, 0xCC, 0x1E, 0xCE, 0x1E, 0xCE, 0x1E,
	0xD0, 0x1E, 0xD0, 0x1E, 0xD2, 0x1E, 0xD2, 0x1E,
	0xD4, 0x1E, 0xD4, 0x1E, 0xD6, 0x1E, 0xD6, 0x1E,
	0xD8, 0x1E, 0xD8, 0x1E, 0xDA, 0x1E, 0xDA, 0x1E,
	0xDC, 0x1E, 0xDC, 0x1E, 0xDE, 0x1E, 0xDE, 0x1E,
	0xE0, 0x1E, 0xE0, 0x1E, 0xE2, 0x1E, 0xE2, 0x1E,
	0xE4, 0x1E, 0xE4, 0x1E, 0xE6, 0x1E, 0xE6, 0x1E,
	0xE8, 0x1E, 0xE8, 0x1E, 0xEA, 0x1E, 0xEA, 0x1E,
	0xEC, 0x1E, 0xEC, 0x1E, 0xEE, 0x1E, 0xEE, 0x1E,
	0xF0, 0x1E, 0xF0, 0x1E, 0xF2, 0x1E, 0xF2, 0x1E,
	0xF4, 0x1E, 0xF4, 0x1E, 0xF6, 0x1E, 0xF6, 0x1E,
	0xF8, 0x1E, 0xF8, 0x1E, 0xFA, 0x1E, 0xFB, 0x1E,
	0xFC, 0x1E, 0xFD, 0x1E, 0xFE, 0x1E, 0xFF, 0x1E,
	0x08, 0x1F, 0x09, 0x1F, 0x0A, 0x1F, 0x0B, 0x1F,
	0x0C, 0x1F, 0x0D, 0x1F, 0x0E, 0x1F, 0x0F, 0x1F,
	0x08, 0x1F, 0x09, 0x1F, 0x0A, 0x1F, 0x0B, 0x1F,
	0x0C, 0x1F, 0x0D, 0x1F, 0x0E, 0x1F, 0x0F, 0x1F,
	0x18, 0x1F, 0x19, 0x1F, 0x1A, 0x1F, 0x1B, 0x1F,
	0x1C, 0x1F, 0x1D, 0x1F, 0x16, 0x1F, 0x17, 0x1F,
	0x18, 0x1F, 0x19, 0x1F, 0x1A, 0x1F, 0x1B, 0x1F,
	0x1C, 0x1F, 0x1D, 0x1F, 0x1E, 0x1F, 0x1F, 0x1F,
	0x28, 0x1F, 0x29, 0x1F, 0x2A, 0x1F, 0x2B, 0x1F,
	0x2C, 0x1F, 0x2D, 0x1F, 0x2E, 0x1F, 0x2F, 0x1F,
	0x28, 0x1F, 0x29, 0x1F, 0x2A, 0x1F, 0x2B, 0x1F,
	0x2C, 0x1F, 0x2D, 0x1F, 0x2E, 0x1F, 0x2F, 0x1F,
	0x38, 0x1F, 0x39, 0x1F, 0x3A, 0x1F, 0x3B, 0x1F,
	0x3C, 0x1F, 0x3D, 0x1F, 0x3E, 0x1F, 0x3F, 0x1F,
	0x38, 0x1F, 0x39, 0x1F, 0x3A, 0x1F, 0x3B, 0x1F,
	0x3C, 0x1F, 0x3D, 0x1F, 0x3E, 0x1F, 0x3F, 0x1F,
	0x48, 0x1F, 0x49, 0x1F, 0x4A, 0x1F, 0x4B, 0x1F,
	0x4C, 0x1F, 0x4D, 0x1F, 0x46, 0x1F, 0x47, 0x1F,
	0x48, 0x1F, 0x49, 0x1F, 0x4A, 0x1F, 0x4B, 0x1F,
	0x4C, 0x1F, 0x4D, 0x1F, 0x4E, 0x1F, 0x4F, 0x1F,
	0x50, 0x1F, 0x59, 0x1F, 0x52, 0x1F, 0x5B, 0x1F,
	0x54, 0x1F, 0x5D, 0x1F, 0x56, 0x1F, 0x5F, 0x1F,
	0x58, 0x1F, 0x59, 0x1F, 0x5A, 0x1F, 0x5B, 0x1F,
	0x5C, 0x1F, 0x5D, 0x1F, 0x5E, 0x1F, 0x5F, 0x1F,
	0x68, 0x1F, 0x69, 0x1F, 0x6A, 0x1F, 0x6B, 0x1F,
	0x6C, 0x1F, 0x6D, 0x1F, 0x6E, 0x1F, 0x6F, 0x1F,
	0x68, 0x1F, 0x69, 0x1F, 0x6A, 0x1F, 0x6B, 0x1F,
	0x6C, 0x1F, 0x6D, 0x1F, 0x6E, 0x1F, 0x6F, 0x1F,
	0xBA, 0x1F, 0xBB, 0x1F, 0xC8, 0x1F, 0xC9, 0x1F,
	0xCA, 0x1F, 0xCB, 0x1F, 0xDA, 0x1F, 0xDB, 0x1F,
	0xF8, 0x1F, 0xF9, 0x1F, 0xEA, 0x1F, 0xEB, 0x1F,
	0xFA, 0x1F, 0xFB, 0x1F, 0x7E, 0x1F, 0x7F, 0x1F,
	0x88, 0x1F, 0x89, 0x1F, 0x8A, 0x1F, 0x8B, 0x1F,
	0x8C, 0x1F, 0x8D, 0x1F, 0x8E, 0x1F, 0x8F, 0x1F,
	0x88, 0x1F, 0x89, 0x1F, 0x8A, 0x1F, 0x8B, 0x1F,
	0x8C, 0x1F, 0x8D, 0x1F, 0x8E, 0x1F, 0x8F, 0x1F,
	0x98, 0x1F, 0x99, 0x1F, 0x9A, 0x1F, 0x9B, 0x1F,
	0x9C, 0x1F, 0x9D, 0x1F, 0x9E, 0x1F, 0x9F, 0x1F,
	0x98, 0x1F, 0x99, 0x1F, 0x9A, 0x1F, 0x9B, 0x1F,
	0x9C, 0x1F, 0x9D, 0x1F, 0x9E, 0x1F, 0x9F, 0x1F,
	0xA8, 0x1F, 0xA9, 0x1F, 0xAA, 0x1F, 0xAB, 0x1F,
	0xAC, 0x1F, 0xAD, 0x1F, 0xAE, 0x1F, 0xAF, 0x1F,
	0xA8, 0x1F, 0xA9, 0x1F, 0xAA, 0x1F, 0xAB, 0x1F,
	0xAC, 0x1F, 0xAD, 0x1F, 0xAE, 0x1F, 0xAF, 0x1F,
	0xB8, 0x1F, 0xB9, 0x1F, 0xB2, 0x1F, 0xBC, 0x1F,
	0xB4, 0x1F, 0xB5, 0x1F, 0xB6, 0x1F, 0xB7, 0x1F,
	0xB8, 0x1F, 0xB9, 0x1F, 0xBA, 0x1F, 0xBB, 0x1F,
	0xBC, 0x1F, 0xBD, 0x1F, 0xBE, 0x1F, 0xBF, 0x1F,
	0xC0, 0x1F, 0xC1, 0x1F, 0xC2, 0x1F, 0xC3, 0x1F,
	0xC4, 0x1F, 0xC5, 0x1F, 0xC6, 0x1F, 0xC7, 0x1F,
	0xC8, 0x1F, 0xC9, 0x1F, 0xCA, 0x1F, 0xCB, 0x1F,
	0xC3, 0x1F, 0xCD, 0x1F, 0xCE, 0x1F, 0xCF, 0x1F,
	0xD8, 0x1F, 0xD9, 0x1F, 0xD2, 0x1F, 0xD3, 0x1F,
	0xD4, 0x1F, 0xD5, 0x1F, 0xD6, 0x1F, 0xD7, 0x1F,
	0xD8, 0x1F, 0xD9, 0x1F, 0xDA, 0x1F, 0xDB, 0x1F,
	0xDC, 0x1F, 0xDD, 0x1F, 0xDE, 0x1F, 0xDF, 0x1F,
	0xE8, 0x1F, 0xE9, 0x1F, 0xE2, 0x1F, 0xE3, 0x1F,
	0xE4, 0x1F, 0xEC, 0x1F, 0xE6, 0x1F, 0xE7, 0x1F,
	0xE8, 0x1F, 0xE9, 0x1F, 0xEA, 0x1F, 0xEB, 0x1F,
	0xEC, 0x1F, 0xED, 0x1F, 0xEE, 0x1F, 0xEF, 0x1F,
	0xF0, 0x1F, 0xF1, 0x1F, 0xF2, 0x1F, 0xF3, 0x1F,
	0xF4, 0x1F, 0xF5, 0x1F, 0xF6, 0x1F, 0xF7, 0x1F,
	0xF8, 0x1F, 0xF9, 0x1F, 0xFA, 0x1F, 0xFB, 0x1F,
	0xF3, 0x1F, 0xFD, 0x1F, 0xFE, 0x1F, 0xFF, 0x1F,
	0x00, 0x20, 0x01, 0x20, 0x02, 0x20, 0x03, 0x20,
	0x04, 0x20, 0x05, 0x20, 0x06, 0x20, 0x07, 0x20,
	0x08, 0x20, 0x09, 0x20, 0x0A, 0x20, 0x0B, 0x20,
	0x0C, 0x20, 0x0D, 0x20, 0x0E, 0x20, 0x0F, 0x20,
	0x10, 0x20, 0x11, 0x20, 0x12, 0x20, 0x13, 0x20,
	0x14, 0x20, 0x15, 0x20, 0x16, 0x20, 0x17, 0x20,
	0x18, 0x20, 0x19, 0x20, 0x1A, 0x20, 0x1B, 0x20,
	0x1C, 0x20, 0x1D, 0x20, 0x1E, 0x20, 0x1F, 0x20,
	0x20, 0x20, 0x21, 0x20, 0x22, 0x20, 0x23, 0x20,
	0x24, 0x20, 0x25, 0x20, 0x26, 0x20, 0x27, 0x20,
	0x28, 0x20, 0x29, 0x20, 0x2A, 0x20, 0x2B, 0x20,
	0x2C, 0x20, 0x2D, 0x20, 0x2E, 0x20, 0x2F, 0x20,
	0x30, 0x20, 0x31, 0x20, 0x32, 0x20, 0x33, 0x20,
	0x34, 0x20, 0x35, 0x20, 0x36, 0x20, 0x37, 0x20,
	0x38, 0x20, 0x39, 0x20, 0x3A, 0x20, 0x3B, 0x20,
	0x3C, 0x20, 0x3D, 0x20, 0x3E, 0x20, 0x3F, 0x20,
	0x40, 0x20, 0x41, 0x20, 0x42, 0x20, 0x43, 0x20,
	0x44, 0x20, 0x45, 0x20, 0x46, 0x20, 0x47, 0x20,
	0x48, 0x20, 0x49, 0x20, 0x4A, 0x20, 0x4B, 0x20,
	0x4C, 0x20, 0x4D, 0x20, 0x4E, 0x20, 0x4F, 0x20,
	0x50, 0x20, 0x51, 0x20, 0x52, 0x20, 0x53, 0x20,
	0x54, 0x20, 0x55, 0x20, 0x56, 0x20, 0x57, 0x20,
	0x58, 0x20, 0x59, 0x20, 0x5A, 0x20, 0x5B, 0x20,
	0x5C, 0x20, 0x5D, 0x20, 0x5E, 0x20, 0x5F, 0x20,
	0x60, 0x20, 0x61, 0x20, 0x62, 0x20, 0x63, 0x20,
	0x64, 0x20, 0x65, 0x20, 0x66, 0x20, 0x67, 0x20,
	0x68, 0x20, 0x69, 0x20, 0x6A, 0x20, 0x6B, 0x20,
	0x6C, 0x20, 0x6D, 0x20, 0x6E, 0x20, 0x6F, 0x20,
	0x70, 0x20, 0x71, 0x20, 0x72, 0x20, 0x73, 0x20,
	0x74, 0x20, 0x75, 0x20, 0x76, 0x20, 0x77, 0x20,
	0x78, 0x20, 0x79, 0x20, 0x7A, 0x20, 0x7B, 0x20,
	0x7C, 0x20, 0x7D, 0x20, 0x7E, 0x20, 0x7F, 0x20,
	0x80, 0x20, 0x81, 0x20, 0x82, 0x20, 0x83, 0x20,
	0x84, 0x20, 0x85, 0x20, 0x86, 0x20, 0x87, 0x20,
	0x88, 0x20, 0x89, 0x20, 0x8A, 0x20, 0x8B, 0x20,
	0x8C, 0x20, 0x8D, 0x20, 0x8E, 0x20, 0x8F, 0x20,
	0x90, 0x20, 0x91, 0x20, 0x92, 0x20, 0x93, 0x20,
	0x94, 0x20, 0x95, 0x20, 0x96, 0x20, 0x97, 0x20,
	0x98, 0x20, 0x99, 0x20, 0x9A, 0x20, 0x9B, 0x20,
	0x9C, 0x20, 0x9D, 0x20, 0x9E, 0x20, 0x9F, 0x20,
	0xA0, 0x20, 0xA1, 0x20, 0xA2, 0x20, 0xA3, 0x20,
	0xA4, 0x20, 0xA5, 0x20, 0xA6, 0x20, 0xA7, 0x20,
	0xA8, 0x20, 0xA9, 0x20, 0xAA, 0x20, 0xAB, 0x20,
	0xAC, 0x20, 0xAD, 0x20, 0xAE, 0x20, 0xAF, 0x20,
	0xB0, 0x20, 0xB1, 0x20, 0xB2, 0x20, 0xB3, 0x20,
	0xB4, 0x20, 0xB5, 0x20, 0xB6, 0x20, 0xB7, 0x20,
	0xB8, 0x20, 0xB9, 0x20, 0xBA, 0x20, 0xBB, 0x20,
	0xBC, 0x20, 0xBD, 0x20, 0xBE, 0x20, 0xBF, 0x20,
	0xC0, 0x20, 0xC1, 0x20, 0xC2, 0x20, 0xC3, 0x20,
	0xC4, 0x20, 0xC5, 0x20, 0xC6, 0x20, 0xC7, 0x20,
	0xC8, 0x20, 0xC9, 0x20, 0xCA, 0x20, 0xCB, 0x20,
	0xCC, 0x20, 0xCD, 0x20, 0xCE, 0x20, 0xCF, 0x20,
	0xD0, 0x20, 0xD1, 0x20, 0xD2, 0x20, 0xD3, 0x20,
	0xD4, 0x20, 0xD5, 0x20, 0xD6, 0x20, 0xD7, 0x20,
	0xD8, 0x20, 0xD9, 0x20, 0xDA, 0x20, 0xDB, 0x20,
	0xDC, 0x20, 0xDD, 0x20, 0xDE, 0x20, 0xDF, 0x20,
	0xE0, 0x20, 0xE1, 0x20, 0xE2, 0x20, 0xE3, 0x20,
	0xE4, 0x20, 0xE5, 0x20, 0xE6, 0x20, 0xE7, 0x20,
	0xE8, 0x20, 0xE9, 0x20, 0xEA, 0x20, 0xEB, 0x20,
	0xEC, 0x20, 0xED, 0x20, 0xEE, 0x20, 0xEF, 0x20,
	0xF0, 0x20, 0xF1, 0x20, 0xF2, 0x20, 0xF3, 0x20,
	0xF4, 0x20, 0xF5, 0x20, 0xF6, 0x20, 0xF7, 0x20,
	0xF8, 0x20, 0xF9, 0x20, 0xFA, 0x20, 0xFB, 0x20,
	0xFC, 0x20, 0xFD, 0x20, 0xFE, 0x20, 0xFF, 0x20,
	0x00, 0x21, 0x01, 0x21, 0x02, 0x21, 0x03, 0x21,
	0x04, 0x21, 0x05, 0x21, 0x06, 0x21, 0x07, 0x21,
	0x08, 0x21, 0x09, 0x21, 0x0A, 0x21, 0x0B, 0x21,
	0x0C, 0x21, 0x0D, 0x21, 0x0E, 0x21, 0x0F, 0x21,
	0x10, 0x21, 0x11, 0x21, 0x12, 0x21, 0x13, 0x21,
	0x14, 0x21, 0x15, 0x21, 0x16, 0x21, 0x17, 0x21,
	0x18, 0x21, 0x19, 0x21, 0x1A, 0x21, 0x1B, 0x21,
	0x1C, 0x21, 0x1D, 0x21, 0x1E, 0x21, 0x1F, 0x21,
	0x20, 0x21, 0x21, 0x21, 0x22, 0x21, 0x23, 0x21,
	0x24, 0x21, 0x25, 0x21, 0x26, 0x21, 0x27, 0x21,
	0x28, 0x21, 0x29, 0x21, 0x2A, 0x21, 0x2B, 0x21,
	0x2C, 0x21, 0x2D, 0x21, 0x2E, 0x21, 0x2F, 0x21,
	0x30, 0x21, 0x31, 0x21, 0x32, 0x21, 0x33, 0x21,
	0x34, 0x21, 0x35, 0x21, 0x36, 0x21, 0x37, 0x21,
	0x38, 0x21, 0x39, 0x21, 0x3A, 0x21, 0x3B, 0x21,
	0x3C, 0x21, 0x3D, 0x21, 0x3E, 0x21, 0x3F, 0x21,
	0x40, 0x21, 0x41, 0x21, 0x42, 0x21, 0x43, 0x21,
	0x44, 0x21, 0x45, 0x21, 0x46, 0x21, 0x47, 0x21,
	0x48, 0x21, 0x49, 0x21, 0x4A, 0x21, 0x4B, 0x21,
	0x4C, 0x21, 0x4D, 0x21, 0x32, 0x21, 0x4F, 0x21,
	0x50, 0x21, 0x51, 0x21, 0x52, 0x21, 0x53, 0x21,
	0x54, 0x21, 0x55, 0x21, 0x56, 0x21, 0x57, 0x21,
	0x58, 0x21, 0x59, 0x21, 0x5A, 0x21, 0x5B, 0x21,
	0x5C, 0x21, 0x5D, 0x21, 0x5E, 0x21, 0x5F, 0x21,
	0x60, 0x21, 0x61, 0x21, 0x62, 0x21, 0x63, 0x21,
	0x64, 0x21, 0x65, 0x21, 0x66, 0x21, 0x67, 0x21,
	0x68, 0x21, 0x69, 0x21, 0x6A, 0x21, 0x6B, 0x21,
	0x6C, 0x21, 0x6D, 0x21, 0x6E, 0x21, 0x6F, 0x21,
	0x60, 0x21, 0x61, 0x21, 0x62, 0x21, 0x63, 0x21,
	0x64, 0x21, 0x65, 0x21, 0x66, 0x21, 0x67, 0x21,
	0x68, 0x21, 0x69, 0x21, 0x6A, 0x21, 0x6B, 0x21,
	0x6C, 0x21, 0x6D, 0x21, 0x6E, 0x21, 0x6F, 0x21,
	0x80, 0x21, 0x81, 0x21, 0x82, 0x21, 0x83, 0x21,
	0x83, 0x21, 0xFF, 0xFF, 0x4B, 0x03, 0xB6, 0x24,
	0xB7, 0x24, 0xB8, 0x24, 0xB9, 0x24, 0xBA, 0x24,
	0xBB, 0x24, 0xBC, 0x24, 0xBD, 0x24, 0xBE, 0x24,
	0xBF, 0x24, 0xC0, 0x24, 0xC1, 0x24, 0xC2, 0x24,
	0xC3, 0x24, 0xC4, 0x24, 0xC5, 0x24, 0xC6, 0x24,
	0xC7, 0x24, 0xC8, 0x24, 0xC9, 0x24, 0xCA, 0x24,
	0xCB, 0x24, 0xCC, 0x24, 0xCD, 0x24, 0xCE, 0x24,
	0xCF, 0x24, 0xFF, 0xFF, 0x46, 0x07, 0x00, 0x2C,
	0x01, 0x2C, 0x02, 0x2C, 0x03, 0x2C, 0x04, 0x2C,
	0x05, 0x2C, 0x06, 0x2C, 0x07, 0x2C, 0x08, 0x2C,
	0x09, 0x2C, 0x0A, 0x2C, 0x0B, 0x2C, 0x0C, 0x2C,
	0x0D, 0x2C, 0x0E, 0x2C, 0x0F, 0x2C, 0x10, 0x2C,
	0x11, 0x2C, 0x12, 0x2C, 0x13, 0x2C, 0x14, 0x2C,
	0x15, 0x2C, 0x16, 0x2C, 0x17, 0x2C, 0x18, 0x2C,
	0x19, 0x2C, 0x1A, 0x2C, 0x1B, 0x2C, 0x1C, 0x2C,
	0x1D, 0x2C, 0x1E, 0x2C, 0x1F, 0x2C, 0x20, 0x2C,
	0x21, 0x2C, 0x22, 0x2C, 0x23, 0x2C, 0x24, 0x2C,
	0x25, 0x2C, 0x26, 0x2C, 0x27, 0x2C, 0x28, 0x2C,
	0x29, 0x2C, 0x2A, 0x2C, 0x2B, 0x2C, 0x2C, 0x2C,
	0x2D, 0x2C, 0x2E, 0x2C, 0x5F, 0x2C, 0x60, 0x2C,
	0x60, 0x2C, 0x62, 0x2C, 0x63, 0x2C, 0x64, 0x2C,
	0x65, 0x2C, 0x66, 0x2C, 0x67, 0x2C, 0x67, 0x2C,
	0x69, 0x2C, 0x69, 0x2C, 0x6B, 0x2C, 0x6B, 0x2C,
	0x6D, 0x2C, 0x6E, 0x2C, 0x6F, 0x2C, 0x70, 0x2C,
	0x71, 0x2C, 0x72, 0x2C, 0x73, 0x2C, 0x74, 0x2C,
	0x75, 0x2C, 0x75, 0x2C, 0x77, 0x2C, 0x78, 0x2C,
	0x79, 0x2C, 0x7A, 0x2C, 0x7B, 0x2C, 0x7C, 0x2C,
	0x7D, 0x2C, 0x7E, 0x2C, 0x7F, 0x2C, 0x80, 0x2C,
	0x80, 0x2C, 0x82, 0x2C, 0x82, 0x2C, 0x84, 0x2C,
	0x84, 0x2C, 0x86, 0x2C, 0x86, 0x2C, 0x88, 0x2C,
	0x88, 0x2C, 0x8A, 0x2C, 0x8A, 0x2C, 0x8C, 0x2C,
	0x8C, 0x2C, 0x8E, 0x2C, 0x8E, 0x2C, 0x90, 0x2C,
	0x90, 0x2C, 0x92, 0x2C, 0x92, 0x2C, 0x94, 0x2C,
	0x94, 0x2C, 0x96, 0x2C, 0x96, 0x2C, 0x98, 0x2C,
	0x98, 0x2C, 0x9A, 0x2C, 0x9A, 0x2C, 0x9C, 0x2C,
	0x9C, 0x2C, 0x9E, 0x2C, 0x9E, 0x2C, 0xA0, 0x2C,
	0xA0, 0x2C, 0xA2, 0x2C, 0xA2, 0x2C, 0xA4, 0x2C,
	0xA4, 0x2C, 0xA6, 0x2C, 0xA6, 0x2C, 0xA8, 0x2C,
	0xA8, 0x2C, 0xAA, 0x2C, 0xAA, 0x2C, 0xAC, 0x2C,
	0xAC, 0x2C, 0xAE, 0x2C, 0xAE, 0x2C, 0xB0, 0x2C,
	0xB0, 0x2C, 0xB2, 0x2C, 0xB2, 0x2C, 0xB4, 0x2C,
	0xB4, 0x2C, 0xB6, 0x2C, 0xB6, 0x2C, 0xB8, 0x2C,
	0xB8, 0x2C, 0xBA, 0x2C, 0xBA, 0x2C, 0xBC, 0x2C,
	0xBC, 0x2C, 0xBE, 0x2C, 0xBE, 0x2C, 0xC0, 0x2C,
	0xC0, 0x2C, 0xC2, 0x2C, 0xC2, 0x2C, 0xC4, 0x2C,
	0xC4, 0x2C, 0xC6, 0x2C, 0xC6, 0x2C, 0xC8, 0x2C,
	0xC8, 0x2C, 0xCA, 0x2C, 0xCA, 0x2C, 0xCC, 0x2C,
	0xCC, 0x2C, 0xCE, 0x2C, 0xCE, 0x2C, 0xD0, 0x2C,
	0xD0, 0x2C, 0xD2, 0x2C, 0xD2, 0x2C, 0xD4, 0x2C,
	0xD4, 0x2C, 0xD6, 0x2C, 0xD6, 0x2C, 0xD8, 0x2C,
	0xD8, 0x2C, 0xDA, 0x2C, 0xDA, 0x2C, 0xDC, 0x2C,
	0xDC, 0x2C, 0xDE, 0x2C, 0xDE, 0x2C, 0xE0, 0x2C,
	0xE0, 0x2C, 0xE2, 0x2C, 0xE2, 0x2C, 0xE4, 0x2C,
	0xE5, 0x2C, 0xE6, 0x2C, 0xE7, 0x2C, 0xE8, 0x2C,
	0xE9, 0x2C, 0xEA, 0x2C, 0xEB, 0x2C, 0xEC, 0x2C,
	0xED, 0x2C, 0xEE, 0x2C, 0xEF, 0x2C, 0xF0, 0x2C,
	0xF1, 0x2C, 0xF2, 0x2C, 0xF3, 0x2C, 0xF4, 0x2C,
	0xF5, 0x2C, 0xF6, 0x2C, 0xF7, 0x2C, 0xF8, 0x2C,
	0xF9, 0x2C, 0xFA, 0x2C, 0xFB, 0x2C, 0xFC, 0x2C,
	0xFD, 0x2C, 0xFE, 0x2C, 0xFF, 0x2C, 0xA0, 0x10,
	0xA1, 0x10, 0xA2, 0x10, 0xA3, 0x10, 0xA4, 0x10,
	0xA5, 0x10, 0xA6, 0x10, 0xA7, 0x10, 0xA8, 0x10,
	0xA9, 0x10, 0xAA, 0x10, 0xAB, 0x10, 0xAC, 0x10,
	0xAD, 0x10, 0xAE, 0x10, 0xAF, 0x10, 0xB0, 0x10,
	0xB1, 0x10, 0xB2, 0x10, 0xB3, 0x10, 0xB4, 0x10,
	0xB5, 0x10, 0xB6, 0x10, 0xB7, 0x10, 0xB8, 0x10,
	0xB9, 0x10, 0xBA, 0x10, 0xBB, 0x10, 0xBC, 0x10,
	0xBD, 0x10, 0xBE, 0x10, 0xBF, 0x10, 0xC0, 0x10,
	0xC1, 0x10, 0xC2, 0x10, 0xC3, 0x10, 0xC4, 0x10,
	0xC5, 0x10, 0xFF, 0xFF, 0x1B, 0xD2, 0x21, 0xFF,
	0x22, 0xFF, 0x23, 0xFF, 0x24, 0xFF, 0x25, 0xFF,
	0x26, 0xFF, 0x27, 0xFF, 0x28, 0xFF, 0x29, 0xFF,
	0x2A, 0xFF, 0x2B, 0xFF, 0x2C, 0xFF, 0x2D, 0xFF,
	0x2E, 0xFF, 0x2F, 0xFF, 0x30, 0xFF, 0x31, 0xFF,
	0x32, 0xFF, 0x33, 0xFF, 0x34, 0xFF, 0x35, 0xFF,
	0x36, 0xFF, 0x37, 0xFF, 0x38, 0xFF, 0x39, 0xFF,
	0x3A, 0xFF, 0x5B, 0xFF, 0x5C, 0xFF, 0x5D, 0xFF,
	0x5E, 0xFF, 0x5F, 0xFF, 0x60, 0xFF, 0x61, 0xFF,
	0x62, 0xFF, 0x63, 0xFF, 0x64, 0xFF, 0x65, 0xFF,
	0x66, 0xFF, 0x67, 0xFF, 0x68, 0xFF, 0x69, 0xFF,
	0x6A, 0xFF, 0x6B, 0xFF, 0x6C, 0xFF, 0x6D, 0xFF,
	0x6E, 0xFF, 0x6F, 0xFF, 0x70, 0xFF, 0x71, 0xFF,
	0x72, 0xFF, 0x73, 0xFF, 0x74, 0xFF, 0x75, 0xFF,
	0x76, 0xFF, 0x77, 0xFF, 0x78, 0xFF, 0x79, 0xFF,
	0x7A, 0xFF, 0x7B, 0xFF, 0x7C, 0xFF, 0x7D, 0xFF,
	0x7E, 0xFF, 0x7F, 0xFF, 0x80, 0xFF, 0x81, 0xFF,
	0x82, 0xFF, 0x83, 0xFF, 0x84, 0xFF, 0x85, 0xFF,
	0x86, 0xFF, 0x87, 0xFF, 0x88, 0xFF, 0x89, 0xFF,
	0x8A, 0xFF, 0x8B, 0xFF, 0x8C, 0xFF, 0x8D, 0xFF,
	0x8E, 0xFF, 0x8F, 0xFF, 0x90, 0xFF, 0x91, 0xFF,
	0x92, 0xFF, 0x93, 0xFF, 0x94, 0xFF, 0x95, 0xFF,
	0x96, 0xFF, 0x97, 0xFF, 0x98, 0xFF, 0x99, 0xFF,
	0x9A, 0xFF, 0x9B, 0xFF, 0x9C, 0xFF, 0x9D, 0xFF,
	0x9E, 0xFF, 0x9F, 0xFF, 0xA0, 0xFF, 0xA1, 0xFF,
	0xA2, 0xFF, 0xA3, 0xFF, 0xA4, 0xFF, 0xA5, 0xFF,
	0xA6, 0xFF, 0xA7, 0xFF, 0xA8, 0xFF, 0xA9, 0xFF,
	0xAA, 0xFF, 0xAB, 0xFF, 0xAC, 0xFF, 0xAD, 0xFF,
	0xAE, 0xFF, 0xAF, 0xFF, 0xB0, 0xFF, 0xB1, 0xFF,
	0xB2, 0xFF, 0xB3, 0xFF, 0xB4, 0xFF, 0xB5, 0xFF,
	0xB6, 0xFF, 0xB7, 0xFF, 0xB8, 0xFF, 0xB9, 0xFF,
	0xBA, 0xFF, 0xBB, 0xFF, 0xBC, 0xFF, 0xBD, 0xFF,
	0xBE, 0xFF, 0xBF, 0xFF, 0xC0, 0xFF, 0xC1, 0xFF,
	0xC2, 0xFF, 0xC3, 0xFF, 0xC4, 0xFF, 0xC5, 0xFF,
	0xC6, 0xFF, 0xC7, 0xFF, 0xC8, 0xFF, 0xC9, 0xFF,
	0xCA, 0xFF, 0xCB, 0xFF, 0xCC, 0xFF, 0xCD, 0xFF,
	0xCE, 0xFF, 0xCF, 0xFF, 0xD0, 0xFF, 0xD1, 0xFF,
	0xD2, 0xFF, 0xD3, 0xFF, 0xD4, 0xFF, 0xD5, 0xFF,
	0xD6, 0xFF, 0xD7, 0xFF, 0xD8, 0xFF, 0xD9, 0xFF,
	0xDA, 0xFF, 0xDB, 0xFF, 0xDC, 0xFF, 0xDD, 0xFF,
	0xDE, 0xFF, 0xDF, 0xFF, 0xE0, 0xFF, 0xE1, 0xFF,
	0xE2, 0xFF, 0xE3, 0xFF, 0xE4, 0xFF, 0xE5, 0xFF,
	0xE6, 0xFF, 0xE7, 0xFF, 0xE8, 0xFF, 0xE9, 0xFF,
	0xEA, 0xFF, 0xEB, 0xFF, 0xEC, 0xFF, 0xED, 0xFF,
	0xEE, 0xFF, 0xEF, 0xFF, 0xF0, 0xFF, 0xF1, 0xFF,
	0xF2, 0xFF, 0xF3, 0xFF, 0xF4, 0xFF, 0xF5, 0xFF,
	0xF6, 0xFF, 0xF7, 0xFF, 0xF8, 0xFF, 0xF9, 0xFF,
	0xFA, 0xFF, 0xFB, 0xFF, 0xFC, 0xFF, 0xFD, 0xFF,
	0xFE, 0xFF, 0xFF, 0xFF
};

static volatile sig_atomic_t got_siginfo;
static void infohandler(int);

#ifndef MAKEFS
static int check_mounted(const char *, mode_t);
#endif
static ssize_t getchunksize(void);
static int getstdfmt(const char *, struct bpb *);
static int getdiskinfo(int, const char *, const char *, int, struct bpb *);
static void print_bpb(struct bpb *);
static int ckgeom(const char *, u_int, const char *);
static void mklabel(u_int8_t *, const char *);
static int oklabel(const char *);
static int exfat_oklabel(const u_int8_t *, int len);
static void setstr(u_int8_t *, const char *, size_t);
static void fill_exfat_buffer(u_int8_t *, u_int, const struct bpb *, const struct msdos_options *);

static int
u8to16char(const u_char **u8strp, u_long *u8lenp, u_char **u16strp, u_long *u16lenp) {
    u_long more;
    unsigned temp;
    u_char c;

    if (*u8lenp == 0)
	return (0);

    c = (*u8strp)[0];

    if ((c & 0x80) == 0) {
	temp = c;
	more = 0;
    } else if ((c & 0xe0) == 0xc0) {
	temp = c & 0x1f;
	more = 1;
    } else if ((c & 0xf0) == 0xe0) {
	temp = c & 0x0f;
	more = 2;
    } else if ((c & 0xf8) == 0xf0) {
	temp = c & 0x07;
	more = 3;
    } else {
	return (-1);
    }

    if (*u8lenp < more + 1)
	return (-1);

    (*u8strp)++;
    *u8lenp -= more + 1;

    while (more-- > 0) {
	temp <<= 6;
	temp |= (u_char)*(*u8strp)++ & 0x3f;
    }

    if ((temp & 0xffff0000) == 0) {
	if (*u16lenp < 2)
	    return (-1);
	*(*u16strp)++ = temp;
	*(*u16strp)++ = temp >> 8;
	*u16lenp -= 2;
    } else {
	if (*u16lenp < 4)
	    return (-1);
	temp -= 0x10000;
	*(*u16strp)++ = (temp >> 10);
	*(*u16strp)++ = 0xD8 | ((temp >> 18) & 0x03);
	*(*u16strp)++ = temp;
	*(*u16strp)++ = 0xDC | ((temp >> 8) & 0x03);
    }
    return (0);
}

static int
u8to16str(const u_char **u8strp, u_long *u8lenp, u_char **u16strp, u_long *u16lenp)
{
    int error = 0;
#ifdef WITH_ICONV
    iconv_t u8to16function;

    setlocale(LC_ALL, "");
    u8to16function = iconv_open("UTF-16LE", "");
    if ((long)u8to16function != -1L) {
	error = iconv(u8to16function, __DECONST(char**, u8strp), u8lenp,
	    (char**)u16strp, u16lenp);
	iconv_close(u8to16function);
	return (error);
    }
#endif
    while (*u8lenp > 0 && *u16lenp > 0 && (*u8strp)[0] != 0 && error == 0) {
	error = u8to16char(u8strp, u8lenp, u16strp, u16lenp);
    }
    return (error);
}

static int
exfat_cksum(u_char *data, int secno, int len, uint32_t cksum) {
    int i;

    for (i = 0; i < len; i++) {
	if (secno == 0 && (i == 106 || i == 107 || i == 112))
	    continue;
	cksum = ((cksum & 1) << 31) + (cksum >> 1) + data[i];
    }
    return (cksum);
}

static void
fill_exfat_bootsec(u_int8_t *buffer, const struct bpb *bpb,
    const struct msdos_options *op)
{
    struct bsexfat *bse;
    struct timespec now;
    int volume_id;

    if (op->volume_id_set != 0)
	volume_id = op->volume_id;
    else
	if (clock_gettime(CLOCK_SECOND, &now) == 0)
	    volume_id = now.tv_sec;
	else
	    volume_id = arc4random();
    bse = (struct bsexfat *)buffer;
    bse->bsJump[0] = 0xeb;
    bse->bsJump[1] = offsetof(struct bsexfat, bsBootCode) - 2;
    bse->bsJump[2] = 0x90;
    setstr(bse->bsFileSystemName, "EXFAT", sizeof(bse->bsFileSystemName));
    le64enc(bse->bsPartitionOffset, op->offset);
    le64enc(bse->bsVolumeLength, bpb->bpbHugeSectors);
    le32enc(bse->bsFatOffset, bpb->bpbResSectors);
    le32enc(bse->bsFatLength, bpb->bpbBigFATsecs);
    le32enc(bse->bsClusterHeapOffset, bpb->bpbClusterHeapOffset);
    le32enc(bse->bsClusterCount, bpb->bpbClusterCount);
    le32enc(bse->bsRootClust, bpb->bpbRootClust);
    le32enc(bse->bsVolSerialNumber, volume_id);
    le16enc(bse->bsFSVers, 0x0100);
    le16enc(bse->bsVolumeFlags, 0x0000);
    bse->bsBytesPerSecShift = bpb->bpbBPSshift;
    bse->bsSecPerClustShift = bpb->bpbSPCshift;
    bse->bsFATs = (u_int8_t)bpb->bpbFATs;
    bse->bsDriveSelect = 0x80;
    bse->bsPercentInUse = 0;
    memset(bse->bsBootCode, 0xf4, sizeof(bse->bsBootCode));
    le16enc(bse->bsBootSectSig, DOSMAGIC);
}

static void
fill_exfat_extbootsec(u_int8_t *buffer, int secsize)
{
    le16enc(buffer + secsize - 4, 0);
    le16enc(buffer + secsize - 2, DOSMAGIC);
}

static void
fill_exfat_cksumsec(u_int8_t *buffer, const struct bpb *bpb, u_int32_t cksum)
{
    u_int secsize, i;

    secsize = bpb->bpbBytesPerSec;
    for (i = 0; i < secsize; i += 4)
	le32enc(buffer + i, cksum);
}

static void
fill_exfat_upcasetable(u_int8_t *buffer, const struct bpb *bpb, u_int secno)
{
    u_int secsize;
    u_int ofs, n;

    secsize = bpb->bpbBytesPerSec;
    ofs = secno * secsize;
    if (ofs < sizeof(compr_upcase_table)) {
	n = sizeof(compr_upcase_table) - ofs;
	if (n > secsize)
	    n = secsize;
	memcpy(buffer, compr_upcase_table + ofs, n);
    }
}

static void
fill_exfat_usedbitmap(u_int8_t *buffer, const struct bpb *bpb, u_int secno)
{
    u_int used_clusters, lastsec;
    int secsize;

    used_clusters = (bpb->bpbRootClust - RESFTE) + 1;
    secsize = bpb->bpbBytesPerSec;
    lastsec = (used_clusters - 1) / (secsize * 8);
    if (secno <= lastsec) {
	if (secno < lastsec) {
	    memset(buffer, 0xff, secsize);
	} else {
	    memset(buffer, 0xff, used_clusters / 8);
	    buffer += used_clusters / 8;
	    used_clusters %= 8;
	    if (used_clusters > 0)
		*buffer = (1 << used_clusters) - 1;
	}
    }
}

static void
fill_exfat_rootdir(u_int8_t *buffer, const struct bpb *bpb,
    const u_char* volume_label, u_int secno)
{
    struct exfatdir_label *p_l;
    struct exfatdir_upcasetable *p_u;
    struct exfatdir_bitmap *p_b;
    const u_char *u8str;
    u_long u8len, u16len;
    u_char *u16labelp;

    u8str = volume_label;
    if (secno == 0) {
	p_l = (struct exfatdir_label*)buffer;
	p_l->type = EX_DE_LABEL;
	if (u8str && *u8str != 0) {
	    u8len = strlen(u8str);
	    u16len = nitems(p_l->label);
	    u16labelp = (u_char*)p_l->label;
	    if (u8to16str(&u8str, &u8len, &u16labelp, &u16len) != 0)
		warn("Bad volume label '%s' truncated at '%s'", volume_label, u8str);
	    p_l->namelength = (sizeof(p_l->label) - u16len) / 2;
	    if (!exfat_oklabel(p_l->label, p_l->namelength)) {
		warnx("Bad volume label '%s' ignored: contains invalid character",
		    volume_label);
		p_l->namelength = 0;
		memset(p_l->label, 0, sizeof(p_l->label));
	    }
	}
	p_b = (struct exfatdir_bitmap*)p_l + 1;
	p_b->type = EX_DE_ALLOCMAP;
	p_b->flags = 0;
	le32enc(p_b->firstcluster, bpb->bpbUsedBitmapClust1);
	le64enc(p_b->datalength, (u_int64_t)howmany(bpb->bpbClusterCount, 8));

	if (bpb->bpbFATs == 2) {
	    p_b++;
	    p_b->type = EX_DE_UPCASETABLE;
	    p_b->flags = EX_FLAG_BITMAP2;
	    le32enc(p_b->firstcluster, bpb->bpbUsedBitmapClust2);
	    le64enc(p_b->datalength, (u_int64_t)howmany(bpb->bpbClusterCount, 8));
	}

	p_u = (struct exfatdir_upcasetable*)p_b + 1;
	p_u->type = EX_DE_UPCASETABLE;
	le32enc(p_u->chksum, compr_upcase_table_cksum);
	le32enc(p_u->firstcluster, bpb->bpbUpcaseTableClust);
	le64enc(p_u->datalength, (u_int64_t)sizeof(compr_upcase_table));
    }
}

static void
fill_exfat_buffer(u_int8_t *buffer, u_int secno, const struct bpb *bpb,
    const struct msdos_options *op)
{
    int secsize, fillsize, fatsec;
    u_int32_t sectype, basesec, segmsize, used_clusters;
    static u_int32_t cksum;

    secsize = bpb->bpbBytesPerSec;
    if (secno < 2 * BACKUPSECOFS) {
	/* Main and backup boot regions. */
	sectype = secno % BACKUPSECOFS;
	switch (sectype) {
	case BOOTSEC:
	    fill_exfat_bootsec(buffer, bpb, op);
	    cksum = 0;
	    break;
	case OEMPARMSEC:
	case RESERVEDSEC:
	    break;
	case BOOTCKSUMSEC:
	    /* Final sector in main and backup boot region. */
	    fill_exfat_cksumsec(buffer, bpb, cksum);
	    break;
	default:
	    assert(EXTBOOTSEC <= sectype && sectype < EXTBOOTSEC + EXTBOOTSECCNT);
	    fill_exfat_extbootsec(buffer, secsize);
	    break;
	}
	cksum = exfat_cksum(buffer, sectype, secsize, cksum);
    } else if (secno >= bpb->bpbResSectors &&
	secno < bpb->bpbResSectors + bpb->bpbFATs * bpb->bpbBigFATsecs) {
	/* FAT region, up to 2 FAT tables are supported */
	fatsec = (secno - bpb->bpbResSectors) % bpb->bpbBigFATsecs;
	used_clusters = bpb->bpbRootClust;
	fillsize = used_clusters * 4 - fatsec * secsize;

	if (fillsize > 0) {
	    if (fillsize > secsize)
		fillsize = secsize;
	    memset(buffer + 4, 0xff, fillsize);
	    if (fatsec == 0)
		le32enc(buffer, 0xfffffff8);
	}
    } else {
	/* Data region. */
	basesec = bpb->bpbClusterHeapOffset;

	basesec += (bpb->bpbUsedBitmapClust1 - RESFTE) << bpb->bpbSPCshift;
	segmsize = bpb->bpbUsedBitmapSectors;
	if (basesec <= secno && secno < basesec + segmsize) {
	    /* Used block bitmap section. */
	    fill_exfat_usedbitmap(buffer, bpb, secno - basesec);
	}
	if (bpb->bpbFATs == 2) {
	    /* Optional 2nd used block bitmap section, if number of FATs == 2. */
	    basesec += (bpb->bpbUsedBitmapClust2 - bpb->bpbUsedBitmapClust1) << bpb->bpbSPCshift;
	    if (basesec <= secno && secno < basesec + segmsize) {
		fill_exfat_usedbitmap(buffer, bpb, secno - basesec);
	    }
	}
	basesec += (bpb->bpbUpcaseTableClust - bpb->bpbUsedBitmapClust2) << bpb->bpbSPCshift;
	segmsize = bpb->bpbUpcaseTableSectors;
	if (basesec <= secno && secno < basesec + segmsize) {
	    /* UTF-16 up-case translation table used for file name matching. */
	    fill_exfat_upcasetable(buffer, bpb, secno - basesec);
	}
	basesec += (bpb->bpbRootClust - bpb->bpbUpcaseTableClust) << bpb->bpbSPCshift;
	segmsize = bpb->bpbUpcaseTableSectors;
	if (basesec <= secno && secno < basesec + segmsize) {
	    /* Root directory with entries for up-case table and used block bitmaps. */
	    fill_exfat_rootdir(buffer, bpb, op->volume_label, secno - basesec);
	}
    }
}

int
mkfs_msdos(const char *fname, const char *dtype, const struct msdos_options *op)
{
    char buf[MAXPATHLEN];
    struct sigaction si_sa;
    struct stat sb;
    struct timeval tv;
    struct bpb bpb;
    struct tm *tm;
    struct bs *bs;
    struct bsbpb *bsbpb;
    struct bsxbpb *bsxbpb;
    struct bsx *bsx;
    struct de *de;
    u_int8_t *img;
    u_int8_t *physbuf, *physbuf_end;
    const char *bname;
    ssize_t n;
    time_t now;
    u_int fat, bss, rds, cls, dir, lsn, x, x1, x2;
    u_int extra_res, alignment, alignto, saved_x, attempts=0;
    bool set_res, set_spf, set_spc;
    int fd, fd1, rv;
    struct msdos_options o = *op;
    ssize_t chunksize;
    u_int maxnft, maxspc, defblk;

    physbuf = NULL;
    rv = -1;
    fd = fd1 = -1;

    if (o.block_size && o.sectors_per_cluster) {
	warnx("Cannot specify both block size and sectors per cluster");
	goto done;
    }
    if (o.OEM_string && strlen(o.OEM_string) > 8) {
	warnx("%s: bad OEM string", o.OEM_string);
	goto done;
    }
    if (o.create_size) {
	if (o.no_create) {
	    warnx("create (-C) is incompatible with -N");
	    goto done;
	}
	fd = open(fname, O_RDWR | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
	    warnx("failed to create %s", fname);
	    goto done;
	}
	if (ftruncate(fd, o.create_size)) {
	    warnx("failed to initialize %jd bytes", (intmax_t)o.create_size);
	    goto done;
	}
    } else if ((fd = open(fname, o.no_create ? O_RDONLY : O_RDWR)) == -1) {
	warn("%s", fname);
	goto done;
    }
    if (fstat(fd, &sb)) {
	warn("%s", fname);
	goto done;
    }
    if (o.create_size) {
	if (!S_ISREG(sb.st_mode))
	    warnx("warning, %s is not a regular file", fname);
    } else {
#ifdef MAKEFS
	errx(1, "o.create_size must be set!");
#else
	if (!S_ISCHR(sb.st_mode))
	    warnx("warning, %s is not a character device", fname);
#endif
    }
#ifndef MAKEFS
    if (!o.no_create)
	if (check_mounted(fname, sb.st_mode) == -1)
	    goto done;
#endif
    if (o.offset && o.offset != lseek(fd, o.offset, SEEK_SET)) {
	warnx("cannot seek to %jd", (intmax_t)o.offset);
	goto done;
    }
    memset(&bpb, 0, sizeof(bpb));
    if (o.floppy) {
	if (getstdfmt(o.floppy, &bpb) == -1)
	    goto done;
	bpb.bpbHugeSectors = bpb.bpbSectors;
	bpb.bpbSectors = 0;
	bpb.bpbBigFATsecs = bpb.bpbFATsecs;
	bpb.bpbFATsecs = 0;
    }
    if (o.drive_heads)
	bpb.bpbHeads = o.drive_heads;
    if (o.sectors_per_track)
	bpb.bpbSecPerTrack = o.sectors_per_track;
    if (o.bytes_per_sector)
	bpb.bpbBytesPerSec = o.bytes_per_sector;
    if (o.size)
	bpb.bpbHugeSectors = o.size;
    if (o.hidden_sectors_set)
	bpb.bpbHiddenSecs = o.hidden_sectors;
    if (!(o.floppy || (o.drive_heads && o.sectors_per_track &&
	o.bytes_per_sector && o.size && o.hidden_sectors_set))) {
	if (getdiskinfo(fd, fname, dtype, o.hidden_sectors_set, &bpb) == -1)
	    goto done;
	bpb.bpbHugeSectors -= (o.offset / bpb.bpbBytesPerSec);
	if (bpb.bpbSecPerClust == 0) {	/* set defaults */
	    if (o.exfat)
		bpb.bpbSecPerClust = 32;	    /* EXFAT default is 32 * 4k */
	    else if (bpb.bpbHugeSectors <= 6000)    /* about 3MB -> 512 bytes */
		bpb.bpbSecPerClust = 1;
	    else if (bpb.bpbHugeSectors <= (1<<17)) /* 64M -> 4k */
		bpb.bpbSecPerClust = 8;
	    else if (bpb.bpbHugeSectors <= (1<<19)) /* 256M -> 8k */
		bpb.bpbSecPerClust = 16;
	    else if (bpb.bpbHugeSectors <= (1<<21)) /* 1G -> 16k */
		bpb.bpbSecPerClust = 32;
	    else
		bpb.bpbSecPerClust = 64;		/* otherwise 32k */
	}
    }
    if (bpb.bpbBytesPerSec < MINBPS ||
        bpb.bpbBytesPerSec > MAXBPS ||
	!powerof2(bpb.bpbBytesPerSec)) {
	warnx("Invalid bytes/sector (%u): must be 512, 1024, 2048 or 4096",
	    bpb.bpbBytesPerSec);
	goto done;
    }

    if (!o.exfat && !oklabel(o.volume_label)) {
	warnx("%s: bad volume label", o.volume_label);
	goto done;
    }
    if (o.exfat) {
	fat = 32;
    } else if (!(fat = o.fat_type)) {
	if (o.floppy)
	    fat = 12;
	else if (!o.directory_entries && (o.info_sector || o.backup_sector))
	    fat = 32;
    }
    if ((fat == 32 && o.directory_entries) || (fat != 32 && (o.info_sector || o.backup_sector))) {
	warnx("-%c is not a legal FAT%s option",
	     fat == 32 ? 'e' : o.info_sector ? 'i' : 'k',
	     fat == 32 ? "32" : "12/16");
	goto done;
    }
    if (o.floppy && fat == 32)
	bpb.bpbRootDirEnts = 0;
    if (fat != 0 && fat != 12 && fat != 16 && fat != 32) {
	warnx("%d: bad FAT type", fat);
	goto done;
    }

    maxspc = o.exfat ? MAXBPC_EX / bpb.bpbBytesPerSec : MAXSPC;
    if (o.block_size) {
	if (!powerof2(o.block_size)) {
	    warnx("block size (%u) is not a power of 2", o.block_size);
	    goto done;
	}
	if (o.block_size < bpb.bpbBytesPerSec) {
	    warnx("block size (%u) is too small; minimum is %u",
		 o.block_size, bpb.bpbBytesPerSec);
	    goto done;
	}
	if (o.block_size > bpb.bpbBytesPerSec * maxspc) {
	    warnx("block size (%u) is too large; maximum is %u",
		 o.block_size, bpb.bpbBytesPerSec * maxspc);
	    goto done;
	}
	bpb.bpbSecPerClust = o.block_size / bpb.bpbBytesPerSec;
    }
    if (o.sectors_per_cluster) {
	if (!powerof2(o.sectors_per_cluster)) {
	    warnx("sectors/cluster (%u) is not a power of 2",
		o.sectors_per_cluster);
	    goto done;
	}
	bpb.bpbSecPerClust = o.sectors_per_cluster;
    }
    if (o.reserved_sectors)
	    bpb.bpbResSectors = o.reserved_sectors;
    maxnft = o.exfat ? MAXNFT_EX : MAXNFT;
    if (o.num_FAT) {
	    if (o.num_FAT > maxnft) {
	    warnx("number of FATs (%u) is too large; maximum is %u",
		 o.num_FAT, maxnft);
	    goto done;
	}
	bpb.bpbFATs = o.num_FAT;
    }
    if (o.directory_entries) {
	bpb.bpbRootDirEnts = roundup(o.directory_entries,
	    bpb.bpbBytesPerSec / sizeof(struct de));
	if (bpb.bpbBytesPerSec == 0 || o.directory_entries >= MAXU16)
	    bpb.bpbRootDirEnts = MAXU16;
    }
    if (o.media_descriptor_set) {
	if (o.media_descriptor < 0xf0) {
	    warnx("illegal media descriptor (%#x)", o.media_descriptor);
	    goto done;
	}
	bpb.bpbMedia = o.media_descriptor;
    }
    if (o.sectors_per_fat)
	bpb.bpbBigFATsecs = o.sectors_per_fat;
    if (o.info_sector)
	bpb.bpbFSInfo = o.info_sector;
    if (o.exfat) {
	bpb.bpbBackup = BACKUPSECOFS;
	bpb.bpbResSectors = 2 * BACKUPSECOFS;
    } else if (o.backup_sector) {
	bpb.bpbBackup = o.backup_sector;
    }
    bss = 1;
    bname = NULL;
    fd1 = -1;
    if (o.bootstrap) {
	bname = o.bootstrap;
	if (!strchr(bname, '/')) {
	    snprintf(buf, sizeof(buf), "/boot/%s", bname);
	    bname = buf;
	}
	if ((fd1 = open(bname, O_RDONLY)) == -1 || fstat(fd1, &sb)) {
	    warn("%s", bname);
	    goto done;
	}
	if (!S_ISREG(sb.st_mode) || sb.st_size % bpb.bpbBytesPerSec ||
	    sb.st_size < bpb.bpbBytesPerSec ||
	    sb.st_size > bpb.bpbBytesPerSec * MAXU16) {
	    warnx("%s: inappropriate file type or format", bname);
	    goto done;
	}
	bss = sb.st_size / bpb.bpbBytesPerSec;
    }
    if (!bpb.bpbFATs)
	bpb.bpbFATs = o.exfat ? 1 : 2;
    if (!fat) {
	if (bpb.bpbHugeSectors < (bpb.bpbResSectors ? bpb.bpbResSectors : bss) +
	    howmany((RESFTE + (bpb.bpbSecPerClust ? MINCLS16 : MAXCLS12 + 1)) *
		(bpb.bpbSecPerClust ? 16 : 12) / BPN,
		bpb.bpbBytesPerSec * NPB) *
	    bpb.bpbFATs +
	    howmany(bpb.bpbRootDirEnts ? bpb.bpbRootDirEnts : DEFRDE,
		    bpb.bpbBytesPerSec / sizeof(struct de)) +
	    (bpb.bpbSecPerClust ? MINCLS16 : MAXCLS12 + 1) *
	    (bpb.bpbSecPerClust ? bpb.bpbSecPerClust :
	     howmany(DEFBLK, bpb.bpbBytesPerSec)))
	    fat = 12;
	else if (bpb.bpbRootDirEnts || bpb.bpbHugeSectors <
		 (bpb.bpbResSectors ? bpb.bpbResSectors : bss) +
		 howmany((RESFTE + MAXCLS16) * 2, bpb.bpbBytesPerSec) *
		 bpb.bpbFATs +
		 howmany(DEFRDE, bpb.bpbBytesPerSec / sizeof(struct de)) +
		 (MAXCLS16 + 1) *
		 (bpb.bpbSecPerClust ? bpb.bpbSecPerClust :
		  howmany(8192, bpb.bpbBytesPerSec)))
	    fat = 16;
	else
	    fat = 32;
    }
    x = bss;
    if (fat == 32 && !o.exfat) {
	if (!bpb.bpbFSInfo) {
	    if (x == MAXU16 || x == bpb.bpbBackup) {
		warnx("no room for info sector");
		goto done;
	    }
	    bpb.bpbFSInfo = x;
	}
	if (bpb.bpbFSInfo != MAXU16 && x <= bpb.bpbFSInfo)
	    x = bpb.bpbFSInfo + 1;
	if (!bpb.bpbBackup) {
	    if (x == MAXU16) {
		warnx("no room for backup sector");
		goto done;
	    }
	    bpb.bpbBackup = x;
	} else if (bpb.bpbBackup != MAXU16 && bpb.bpbBackup == bpb.bpbFSInfo) {
	    warnx("backup sector would overwrite info sector");
	    goto done;
	}
	if (bpb.bpbBackup != MAXU16 && x <= bpb.bpbBackup)
	    x = bpb.bpbBackup + 1;
    }

    extra_res = 0;
    alignment = 0;
    set_res = (bpb.bpbResSectors == 0);
    set_spf = (bpb.bpbBigFATsecs == 0);
    set_spc = (bpb.bpbSecPerClust == 0);
    saved_x = x;

    /*
     * Attempt to align the root directory to cluster if o.align is set.
     * This is done by padding with reserved blocks. Note that this can
     * cause other factors to change, which can in turn change the alignment.
     * This should take at most 2 iterations, as increasing the reserved
     * amount may cause the FAT size to decrease by 1, requiring another
     * bpbFATs reserved blocks. If bpbSecPerClust changes, it will
     * be half of its previous size, and thus will not throw off alignment.
     */
    do {
	x = saved_x;
	if (set_res)
	    bpb.bpbResSectors = ((fat == 32) ?
		MAX(x, MAX(16384 / bpb.bpbBytesPerSec, 4)) : x) + extra_res;
	else if (bpb.bpbResSectors < x) {
	    warnx("too few reserved sectors (need %d have %d)", x,
		bpb.bpbResSectors);
	    goto done;
	}
	if (fat != 32 && !bpb.bpbRootDirEnts)
	    bpb.bpbRootDirEnts = DEFRDE;
	rds = howmany(bpb.bpbRootDirEnts,
	    bpb.bpbBytesPerSec / sizeof(struct de));
	defblk = fat == 16 ? DEFBLK16 : (o.exfat ? DEFBLK_EX : DEFBLK);
	if (set_spc) {
	    for (bpb.bpbSecPerClust = howmany(defblk, bpb.bpbBytesPerSec);
		bpb.bpbSecPerClust < maxspc && (bpb.bpbResSectors +
		    howmany((RESFTE + maxcls(fat)) * (fat / BPN),
			bpb.bpbBytesPerSec * NPB) * bpb.bpbFATs +
		    rds +
		    (u_int64_t) (maxcls(fat) + 1) * bpb.bpbSecPerClust) <=
		    bpb.bpbHugeSectors;
		bpb.bpbSecPerClust <<= 1)
		    continue;

	}
	if (fat != 32 && bpb.bpbBigFATsecs > MAXU16) {
	    warnx("too many sectors/FAT for FAT12/16");
	    goto done;
	}
	x1 = bpb.bpbResSectors + rds;
	x = bpb.bpbBigFATsecs ? bpb.bpbBigFATsecs : 1;
	if (x1 + (u_int64_t)x * bpb.bpbFATs > bpb.bpbHugeSectors) {
	    warnx("meta data exceeds file system size");
	    goto done;
	}
	x1 += x * bpb.bpbFATs;
	x = (u_int64_t)(bpb.bpbHugeSectors - x1) * bpb.bpbBytesPerSec * NPB /
	    (bpb.bpbSecPerClust * bpb.bpbBytesPerSec * NPB +
	    fat / BPN * bpb.bpbFATs);
	x2 = howmany((RESFTE + MIN(x, maxcls(fat))) * (fat / BPN),
	    bpb.bpbBytesPerSec * NPB);
	if (set_spf) {
	    if (bpb.bpbBigFATsecs == 0)
		bpb.bpbBigFATsecs = x2;
	    x1 += (bpb.bpbBigFATsecs - 1) * bpb.bpbFATs;
	}
	if (set_res) {
	    alignto = bpb.bpbSecPerClust;
	    if (alignto > 1) {
		/* align data clusters */
		alignment = (bpb.bpbResSectors + bpb.bpbBigFATsecs * bpb.bpbFATs + rds) %
		    alignto;
		if (alignment != 0)
		    extra_res += alignto - alignment;
	    }
	}
	attempts++;
    } while (alignment != 0 && attempts < 2);
    if (o.align && alignment != 0)
	warnx("warning: Alignment failed.");

    cls = (bpb.bpbHugeSectors - x1) / bpb.bpbSecPerClust;
    x = (u_int64_t)bpb.bpbBigFATsecs * bpb.bpbBytesPerSec * NPB / (fat / BPN) -
	RESFTE;
    if (cls > x)
	cls = x;
    if (bpb.bpbBigFATsecs < x2)
	warnx("warning: sectors/FAT limits file system to %u clusters",
	      cls);
    if (!o.exfat && cls < mincls(fat)) {
	warnx("%u clusters too few clusters for FAT%u, need %u", cls, fat,
	    mincls(fat));
	goto done;
    }
    if (cls > maxcls(fat)) {
	cls = maxcls(fat);
	bpb.bpbHugeSectors = x1 + (cls + 1) * bpb.bpbSecPerClust - 1;
	warnx("warning: FAT type limits file system to %lu sectors",
	      bpb.bpbHugeSectors);
    }
    printf("%s: %u sector%s in %u FAT%u cluster%s "
	   "(%u bytes/cluster)\n", fname, cls * bpb.bpbSecPerClust,
	   cls * bpb.bpbSecPerClust == 1 ? "" : "s", cls, fat,
	   cls == 1 ? "" : "s", bpb.bpbBytesPerSec * bpb.bpbSecPerClust);
    if (o.exfat) {
	bpb.bpbBPSshift = fls(bpb.bpbBytesPerSec) - 1;
	bpb.bpbSPCshift = fls(bpb.bpbSecPerClust) - 1;
	bpb.bpbClusterHeapOffset = howmany(bpb.bpbResSectors + bpb.bpbFATs * bpb.bpbBigFATsecs,
		bpb.bpbSecPerClust) * bpb.bpbSecPerClust;
	bpb.bpbClusterCount = (bpb.bpbHugeSectors - bpb.bpbClusterHeapOffset) >> bpb.bpbSPCshift;
	bpb.bpbUpcaseTableSectors = howmany(sizeof(compr_upcase_table),
	    bpb.bpbBytesPerSec);
	bpb.bpbUsedBitmapSectors = howmany(howmany(bpb.bpbClusterCount, 8),
	    bpb.bpbBytesPerSec);
        bpb.bpbUsedBitmapClust1 = RESFTE;
        bpb.bpbUsedBitmapClust2 = bpb.bpbUsedBitmapClust1 +
	    (bpb.bpbFATs == 2 ? howmany(bpb.bpbUsedBitmapSectors, bpb.bpbSecPerClust) : 0);
	bpb.bpbUpcaseTableClust = bpb.bpbUsedBitmapClust2 +
	    howmany(bpb.bpbUsedBitmapSectors, bpb.bpbSecPerClust);
        bpb.bpbRootClust = bpb.bpbUpcaseTableClust +
	    howmany(bpb.bpbUpcaseTableSectors, bpb.bpbSecPerClust);
    } else {
	if (fat == 32)
	   bpb.bpbRootClust = RESFTE;
    }
    if (!bpb.bpbMedia)
	bpb.bpbMedia = !bpb.bpbHiddenSecs ? 0xf0 : 0xf8;
    if (!o.exfat && bpb.bpbHugeSectors <= MAXU16) {
	bpb.bpbSectors = bpb.bpbHugeSectors;
	bpb.bpbHugeSectors = 0;
    }
    if (fat != 32) {
	bpb.bpbFATsecs = bpb.bpbBigFATsecs;
	bpb.bpbBigFATsecs = 0;
    }
    print_bpb(&bpb);
    if (!o.no_create) {
	if (o.timestamp_set) {
	    tv.tv_sec = now = o.timestamp;
	    tv.tv_usec = 0;
	    tm = gmtime(&now);
	} else {
	    gettimeofday(&tv, NULL);
	    now = tv.tv_sec;
	    tm = localtime(&now);
	}
	if (!o.volume_id_set)
	    o.volume_id = (((u_int)(1 + tm->tm_mon) << 8 |
	        (u_int)tm->tm_mday) + ((u_int)tm->tm_sec << 8 |
		(u_int)(tv.tv_usec / 10))) << 16 |
		((u_int)(1900 + tm->tm_year) +
		    ((u_int)tm->tm_hour << 8 |
	        (u_int)tm->tm_min));

	chunksize = getchunksize();
	physbuf = malloc(chunksize);
	if (physbuf == NULL) {
	    warn(NULL);
	    goto done;
	}
	physbuf_end = physbuf + chunksize;
	img = physbuf;

	if (o.exfat)
	    dir = bpb.bpbClusterHeapOffset +
		((bpb.bpbRootClust - RESFTE) << bpb.bpbSPCshift);
	else
	    dir = bpb.bpbResSectors +
		(bpb.bpbFATsecs ? bpb.bpbFATsecs : bpb.bpbBigFATsecs) * bpb.bpbFATs;
	memset(&si_sa, 0, sizeof(si_sa));
	si_sa.sa_handler = infohandler;
#ifdef SIGINFO
	if (sigaction(SIGINFO, &si_sa, NULL) == -1) {
	    warn("sigaction SIGINFO");
	    goto done;
	}
#endif
	for (lsn = 0; lsn < dir + (fat == 32 ? bpb.bpbSecPerClust : rds); lsn++) {
	    if (got_siginfo) {
		    fprintf(stderr,"%s: writing sector %u of %u (%u%%)\n",
			fname, lsn,
			(dir + (fat == 32 ? bpb.bpbSecPerClust: rds)),
			(lsn * 100) / (dir +
			    (fat == 32 ? bpb.bpbSecPerClust: rds)));
		    got_siginfo = 0;
	    }
	    x = lsn;
	    if (o.bootstrap &&
		fat == 32 && bpb.bpbBackup != MAXU16 &&
		bss <= bpb.bpbBackup && x >= bpb.bpbBackup) {
		x -= bpb.bpbBackup;
		if (!x && lseek(fd1, o.offset, SEEK_SET)) {
		    warn("%s", bname);
		    goto done;
		}
	    }
	    if (o.bootstrap && x < bss) {
		if ((n = read(fd1, img, bpb.bpbBytesPerSec)) == -1) {
		    warn("%s", bname);
		    goto done;
		}
		if ((unsigned)n != bpb.bpbBytesPerSec) {
		    warnx("%s: can't read sector %u", bname, x);
		    goto done;
		}
	    } else
		memset(img, 0, bpb.bpbBytesPerSec);
	    if (o.exfat) {
		fill_exfat_buffer(img, lsn, &bpb, op);
		goto secfilled;
	    }
	    if (!lsn ||
		(fat == 32 && bpb.bpbBackup != MAXU16 &&
		 lsn == bpb.bpbBackup)) {
		x1 = sizeof(struct bs);
		bsbpb = (struct bsbpb *)(img + x1);
		mk2(bsbpb->bpbBytesPerSec, bpb.bpbBytesPerSec);
		mk1(bsbpb->bpbSecPerClust, bpb.bpbSecPerClust);
		mk2(bsbpb->bpbResSectors, bpb.bpbResSectors);
		mk1(bsbpb->bpbFATs, bpb.bpbFATs);
		mk2(bsbpb->bpbRootDirEnts, bpb.bpbRootDirEnts);
		mk2(bsbpb->bpbSectors, bpb.bpbSectors);
		mk1(bsbpb->bpbMedia, bpb.bpbMedia);
		mk2(bsbpb->bpbFATsecs, bpb.bpbFATsecs);
		mk2(bsbpb->bpbSecPerTrack, bpb.bpbSecPerTrack);
		mk2(bsbpb->bpbHeads, bpb.bpbHeads);
		mk4(bsbpb->bpbHiddenSecs, bpb.bpbHiddenSecs);
		mk4(bsbpb->bpbHugeSectors, bpb.bpbHugeSectors);
		x1 += sizeof(struct bsbpb);
		if (fat == 32) {
		    bsxbpb = (struct bsxbpb *)(img + x1);
		    mk4(bsxbpb->bpbBigFATsecs, bpb.bpbBigFATsecs);
		    mk2(bsxbpb->bpbExtFlags, 0);
		    mk2(bsxbpb->bpbFSVers, 0);
		    mk4(bsxbpb->bpbRootClust, bpb.bpbRootClust);
		    mk2(bsxbpb->bpbFSInfo, bpb.bpbFSInfo);
		    mk2(bsxbpb->bpbBackup, bpb.bpbBackup);
		    x1 += sizeof(struct bsxbpb);
		}
		bsx = (struct bsx *)(img + x1);
		mk1(bsx->exBootSignature, 0x29);
		x = o.volume_id;
		mk4(bsx->exVolumeID, o.volume_id);
		mklabel(bsx->exVolumeLabel, o.volume_label ? o.volume_label : "NO NAME");
		snprintf(buf, sizeof(buf), "FAT%u", fat);
		setstr(bsx->exFileSysType, buf, sizeof(bsx->exFileSysType));
		if (!o.bootstrap) {
		    x1 += sizeof(struct bsx);
		    bs = (struct bs *)img;
		    mk1(bs->bsJump[0], 0xeb);
		    mk1(bs->bsJump[1], x1 - 2);
		    mk1(bs->bsJump[2], 0x90);
		    setstr(bs->bsOemName, o.OEM_string ? o.OEM_string : "BSD4.4  ",
			   sizeof(bs->bsOemName));
		    memcpy(img + x1, bootcode, sizeof(bootcode));
		    mk2(img + MINBPS - 2, DOSMAGIC);
		}
	    } else if (fat == 32 && bpb.bpbFSInfo != MAXU16 &&
		       (lsn == bpb.bpbFSInfo ||
			(bpb.bpbBackup != MAXU16 &&
			 lsn == bpb.bpbBackup + bpb.bpbFSInfo))) {
		mk4(img, 0x41615252);
		mk4(img + MINBPS - 28, 0x61417272);
		mk4(img + MINBPS - 24, 0xffffffff);
		mk4(img + MINBPS - 20, 0xffffffff);
		mk2(img + MINBPS - 2, DOSMAGIC);
	    } else if (lsn >= bpb.bpbResSectors && lsn < dir &&
		       !((lsn - bpb.bpbResSectors) %
			 (bpb.bpbFATsecs ? bpb.bpbFATsecs :
			  bpb.bpbBigFATsecs))) {
		mk1(img[0], bpb.bpbMedia);
		for (x = 1; x < fat * (fat == 32 ? 3 : 2) / 8; x++)
		    mk1(img[x], fat == 32 && x % 4 == 3 ? 0x0f : 0xff);
	    } else if (lsn == dir && o.volume_label) {
		de = (struct de *)img;
		mklabel(de->deName, o.volume_label);
		mk1(de->deAttributes, 050);
		x = (u_int)tm->tm_hour << 11 |
		    (u_int)tm->tm_min << 5 |
		    (u_int)tm->tm_sec >> 1;
		mk2(de->deMTime, x);
		x = (u_int)(tm->tm_year - 80) << 9 |
		    (u_int)(tm->tm_mon + 1) << 5 |
		    (u_int)tm->tm_mday;
		mk2(de->deMDate, x);
	    }
secfilled:
	    /*
	     * Issue a write of chunksize once we have collected
	     * enough sectors.
	     */
	    img += bpb.bpbBytesPerSec;
	    if (img >= physbuf_end) {
		n = write(fd, physbuf, chunksize);
		if (n != chunksize) {
		    warnx("%s: can't write sector %u", fname, lsn);
		    goto done;
		}
		img = physbuf;
	    }
	}
	/*
	 * Write remaining sectors, if the last write didn't end
	 * up filling a whole chunk.
	 */
	if (img != physbuf) {
		ssize_t tailsize = img - physbuf;

		n = write(fd, physbuf, tailsize);
		if (n != tailsize) {
		    warnx("%s: can't write sector %u", fname, lsn);
		    goto done;
		}
	}
    }
    rv = 0;
done:
    free(physbuf);
    if (fd != -1)
	    close(fd);
    if (fd1 != -1)
	    close(fd1);

    return rv;
}

/*
 * return -1 with error if file system is mounted.
 */
#ifndef MAKEFS
static int
check_mounted(const char *fname, mode_t mode)
{
/*
 * If getmntinfo() is not available (e.g. Linux) don't check. This should
 * not be a problem since we will only be using makefs to create images.
 */
    struct statfs *mp;
    const char *s1, *s2;
    size_t len;
    int n, r;

    if (!(n = getmntinfo(&mp, MNT_NOWAIT))) {
	warn("getmntinfo");
	return -1;
    }
    len = strlen(_PATH_DEV);
    s1 = fname;
    if (!strncmp(s1, _PATH_DEV, len))
	s1 += len;
    r = S_ISCHR(mode) && s1 != fname && *s1 == 'r';
    for (; n--; mp++) {
	s2 = mp->f_mntfromname;
	if (!strncmp(s2, _PATH_DEV, len))
	    s2 += len;
	if ((r && s2 != mp->f_mntfromname && !strcmp(s1 + 1, s2)) ||
	    !strcmp(s1, s2)) {
	    warnx("%s is mounted on %s", fname, mp->f_mntonname);
	    return -1;
	}
    }
    return 0;
}
#endif

/*
 * Get optimal I/O size
 */
static ssize_t
getchunksize(void)
{
	static ssize_t chunksize;

	if (chunksize != 0)
		return (chunksize);

#ifdef	KERN_MAXPHYS
	int mib[2];
	size_t len;

	mib[0] = CTL_KERN;
	mib[1] = KERN_MAXPHYS;
	len = sizeof(chunksize);

	if (sysctl(mib, 2, &chunksize, &len, NULL, 0) == -1) {
		warn("sysctl: KERN_MAXPHYS, using %zu", (size_t)MAXPHYS);
		chunksize = 0;
	}
#endif
	if (chunksize == 0)
		chunksize = MAXPHYS;

	/*
	 * For better performance, we want to write larger chunks instead of
	 * individual sectors (the size can only be 512, 1024, 2048 or 4096
	 * bytes). Assert that chunksize can always hold an integer number of
	 * sectors by asserting that both are power of two numbers and the
	 * chunksize is greater than MAXBPS.
	 */
	static_assert(powerof2(MAXBPS), "MAXBPS is not power of 2");
	assert(powerof2(chunksize));
	assert(chunksize > MAXBPS);

	return (chunksize);
}

/*
 * Get a standard format.
 */
static int
getstdfmt(const char *fmt, struct bpb *bpb)
{
    u_int x, i;

    x = nitems(stdfmt);
    for (i = 0; i < x && strcmp(fmt, stdfmt[i].name); i++);
    if (i == x) {
	warnx("%s: unknown standard format", fmt);
	return -1;
    }
    *bpb = stdfmt[i].bpb;
    return 0;
}

static void
compute_geometry_from_file(int fd, const char *fname, struct disklabel *lp)
{
	struct stat st;
	off_t ms;

	if (fstat(fd, &st))
		err(1, "cannot get disk size");
	if (!S_ISREG(st.st_mode))
		errx(1, "%s is not a regular file", fname);
	ms = st.st_size;
	lp->d_secsize = 512;
	lp->d_nsectors = 63;
	lp->d_ntracks = 255;
	lp->d_secperunit = ms / lp->d_secsize;
}

/*
 * Get disk slice, partition, and geometry information.
 */
static int
getdiskinfo(int fd, const char *fname, const char *dtype, __unused int oflag,
	    struct bpb *bpb)
{
    struct disklabel *lp, dlp;
    off_t hs = 0;
#ifndef MAKEFS
    off_t ms;
    struct fd_type type;

    lp = NULL;

    /* If the user specified a disk type, try to use that */
    if (dtype != NULL) {
	lp = getdiskbyname(dtype);
    }

    /* Maybe it's a floppy drive */
    if (lp == NULL) {
	if (ioctl(fd, DIOCGMEDIASIZE, &ms) == -1) {
	    /* create a fake geometry for a file image */
	    compute_geometry_from_file(fd, fname, &dlp);
	    lp = &dlp;
	} else if (ioctl(fd, FD_GTYPE, &type) != -1) {
	    dlp.d_secsize = 128 << type.secsize;
	    dlp.d_nsectors = type.sectrac;
	    dlp.d_ntracks = type.heads;
	    dlp.d_secperunit = ms / dlp.d_secsize;
	    lp = &dlp;
	}
    }

    /* Maybe it's a fixed drive */
    if (lp == NULL) {
	if (bpb->bpbBytesPerSec)
	    dlp.d_secsize = bpb->bpbBytesPerSec;
	if (bpb->bpbBytesPerSec == 0 && ioctl(fd, DIOCGSECTORSIZE,
					      &dlp.d_secsize) == -1)
	    err(1, "cannot get sector size");

	dlp.d_secperunit = ms / dlp.d_secsize;

	if (bpb->bpbSecPerTrack == 0 && ioctl(fd, DIOCGFWSECTORS,
					      &dlp.d_nsectors) == -1) {
	    warn("cannot get number of sectors per track");
	    dlp.d_nsectors = 63;
	}
	if (bpb->bpbHeads == 0 &&
	    ioctl(fd, DIOCGFWHEADS, &dlp.d_ntracks) == -1) {
	    warn("cannot get number of heads");
	    if (dlp.d_secperunit <= 63*1*1024)
		dlp.d_ntracks = 1;
	    else if (dlp.d_secperunit <= 63*16*1024)
		dlp.d_ntracks = 16;
	    else
		dlp.d_ntracks = 255;
	}

	hs = (ms / dlp.d_secsize) - dlp.d_secperunit;
	lp = &dlp;
    }
#else
    (void)dtype;
    /* In the makefs case we only support image files: */
    compute_geometry_from_file(fd, fname, &dlp);
    lp = &dlp;
#endif

    if (bpb->bpbBytesPerSec == 0) {
	if (ckgeom(fname, lp->d_secsize, "bytes/sector") == -1)
	    return -1;
	bpb->bpbBytesPerSec = lp->d_secsize;
    }
    if (bpb->bpbSecPerTrack == 0) {
	if (ckgeom(fname, lp->d_nsectors, "sectors/track") == -1)
	    return -1;
	bpb->bpbSecPerTrack = lp->d_nsectors;
    }
    if (bpb->bpbHeads == 0) {
	if (ckgeom(fname, lp->d_ntracks, "drive heads") == -1)
	    return -1;
	bpb->bpbHeads = lp->d_ntracks;
    }
    if (bpb->bpbHugeSectors == 0)
	bpb->bpbHugeSectors = lp->d_secperunit;
    if (bpb->bpbHiddenSecs == 0)
	bpb->bpbHiddenSecs = hs;
    return 0;
}

/*
 * Print out BPB values.
 */
static void
print_bpb(struct bpb *bpb)
{
    printf("BytesPerSec=%u SecPerClust=%u ResSectors=%u FATs=%u",
	   bpb->bpbBytesPerSec, bpb->bpbSecPerClust, bpb->bpbResSectors,
	   bpb->bpbFATs);
    if (bpb->bpbRootDirEnts)
	printf(" RootDirEnts=%u", bpb->bpbRootDirEnts);
    if (bpb->bpbSectors)
	printf(" Sectors=%u", bpb->bpbSectors);
    printf(" Media=%#x", bpb->bpbMedia);
    if (bpb->bpbFATsecs)
	printf(" FATsecs=%u", bpb->bpbFATsecs);
    printf(" SecPerTrack=%u Heads=%u HiddenSecs=%u", bpb->bpbSecPerTrack,
	   bpb->bpbHeads, bpb->bpbHiddenSecs);
    if (bpb->bpbHugeSectors)
	printf(" HugeSectors=%llu", (unsigned long long)bpb->bpbHugeSectors);
    if (!bpb->bpbFATsecs) {
	printf(" FATsecs=%u RootCluster=%u", bpb->bpbBigFATsecs,
	       bpb->bpbRootClust);
	printf(" FSInfo=");
	printf(bpb->bpbFSInfo == MAXU16 ? "%#x" : "%u", bpb->bpbFSInfo);
	printf(" Backup=");
	printf(bpb->bpbBackup == MAXU16 ? "%#x" : "%u", bpb->bpbBackup);
    }
    printf("\n");
}

/*
 * Check a disk geometry value.
 */
static int
ckgeom(const char *fname, u_int val, const char *msg)
{
    if (!val) {
	warnx("%s: no default %s", fname, msg);
	return -1;
    }
    if (val > MAXU16) {
	warnx("%s: illegal %s %d", fname, msg, val);
	return -1;
    }
    return 0;
}

/*
 * Check a volume label.
 */
static int
oklabel(const char *src)
{
    int c, i;

    for (i = 0; i <= 11; i++) {
	c = (u_char)*src++;
	if (c < ' ' + !i || strchr("\"*+,./:;<=>?[\\]|", c))
	    break;
    }
    return i && !c;
}

static int
exfat_oklabel(const u_int8_t *src, int len)
{
    int i;
    u_int16_t c;

    for (i = 0; i < len; i++) {
	c = src[0] + (src[1] << 8);
	if (c < ' ' || (c <= 0xff && strchr("\"*/:<>?[\\]|", c)))
	    break;
	src += 2;
    }
    return (i == len);
}

/*
 * Make a volume label.
 */
static void
mklabel(u_int8_t *dest, const char *src)
{
    int c, i;

    for (i = 0; i < 11; i++) {
	c = *src ? toupper(*src++) : ' ';
	*dest++ = !i && c == '\xe5' ? 5 : c;
    }
}

/*
 * Copy string, padding with spaces.
 */
static void
setstr(u_int8_t *dest, const char *src, size_t len)
{
    while (len--)
	*dest++ = *src ? *src++ : ' ';
}

static void
infohandler(int sig __unused)
{

	got_siginfo = 1;
}
